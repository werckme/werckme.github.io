[{"path": "chords/default.chords", "data": "------------------------------------------------------------------\nX: \t\t\tI=0\t    \t\tIII=4 \t\t\tV=7\nXmin: \t\tI=0     \t\tIII=3 \t\t\tV=7\nX-: \t\tI=0     \t\tIII=3 \t\t\tV=7\nX/7: \t\tI=0     \t\tIII=4 \t\t\tV=7 \t\t\tVII=-2\nX-/7: \t\tI=0     \t\tIII=3 \t\t\tV=7 \t\t\tVII=-2\nX/maj7: \tI=0          \tIII=4 \t\t\tV=7 \t\t\tVII=-1\nX/5: \t\tI=0\t    \t\tIII=4 \t\t\tV=-5\nX-/5: \t\tI=0\t    \t\tIII=3 \t\t\tV=-5\nX/4: \t\tI=0\t    \t\tIII=4 \tIV=-7\tV=7\nX-/4: \t\tI=0\t    \t\tIII=3 \tIV=-7\tV=7\nX/3: \t\tI=0\t    \t\tIII=-8 \t    \tV=7\nX-/3: \t\tI=0\t    \t\tIII=-9 \t    \tV=7\nX/2: \t\tI=0\t    II=-10\tIII=4 \t    \tV=7\n------------------------------------------------------------------\nXsus4:      I=0                     IV=5    V=7\nX7sus4:     I=0                     IV=5    V=7             VII=10\nX9sus4:     I=0     II=2            IV=5    V=7             VII=10\nXsus2:      I=0     II=2                    V=7\n------------------------------------------------------------------\nX6:         I=0     \t\tIII=4 \t\t\tV=7     VI=9\nX-6:        I=0     \t\tIII=3 \t\t\tV=7     VI=9\nX-6/9:      I=0     II=2\tIII=3 \t\t\tV=7     VI=9\n------------------------------------------------------------------\nX7: \t\tI=0     \t\tIII=4 \t\t\tV=7 \t\t\tVII=10\nXmin7: \t\tI=0     \t\tIII=3 \t\t\tV=7 \t\t\tVII=10\nX-7: \t\tI=0     \t\tIII=3 \t\t\tV=7 \t\t\tVII=10\nXmaj7: \t\tI=0     \t\tIII=4 \t\t\tV=7 \t\t\tVII=11\nXmaj7b5:\tI=0     \t\tIII=4 \t\t\tV=6 \t\t\tVII=11\nX-7b5:  \tI=0     \t\tIII=3 \t\t\tV=6 \t\t\tVII=10\nXmaj7#11: \tI=0     \t\tIII=4 \tIV=6\t     \t\t\tVII=11\nX7b5: \t\tI=0     \t\tIII=4 \t\t\tV=6 \t\t\tVII=10\nX7#5: \t\tI=0     \t\tIII=4 \t\t\tV=8 \t\t\tVII=10\nX07: \t\tI=0     \t\tIII=3 \t\t\tV=6 \t\t\tVII=9\n-- II=3 and III=3 was intended\nX7#5#9:\t\tI=0     II=3    III=3          \tV=8 \t\t\tVII=10\n------------------------------------------------------------------\nX2: \t\tI=0             III=2 \t\t\tV=7 \t\t\t\nX9: \t\tI=0     II=2    III=4 \t\t\tV=7 \t\t\tVII=10\n# to distinguish between Xb9 (Xflat and 9) and Xb9 (X and flat 9)\n# we write Xflat9 for the latter. (same for 11 and 13)\nXflat9: \tI=0     II=1    III=4 \t\t\tV=7 \t\t\t\nXmin9: \t\tI=0     II=2\tIII=3 \t\t\tV=7 \t\t\tVII=10\nX-9: \t\tI=0     II=2\tIII=3 \t\t\tV=7 \t\t\tVII=10\nXminAdd9:\tI=0     II=2\tIII=3 \t\t\tV=7 \t\t\t\nX-add9:\t\tI=0     II=2\tIII=3 \t\t\tV=7 \t\t\t\n\n\nXmaj9: \t\tI=0     II=2\tIII=4 \t\t\tV=7 \t\t\tVII=11\n-- II=3 and III=3 was intended\nX7#9: \t\tI=0     II=3\tIII=4  \t\t\tV=7 \t\t\tVII=10\nX7b9:       I=0     II=1    III=4 \t\t\tV=7 \t\t\tVII=10\nXmaj7b9:    I=0     II=1    III=4 \t\t\tV=7 \t\t\tVII=11\n------------------------------------------------------------------\nX11: \t\tI=0         \tIII=4 \tIV=5\tV=7 \t\t\tVII=10\nXflat11:    I=0         \tIII=3 \tIV=4\tV=7 \t\t\t\nXmin11:\t\tI=0         \tIII=3 \tIV=5\tV=7 \t\t\tVII=10\nX-11:\t\tI=0         \tIII=3 \tIV=5\tV=7 \t\t\tVII=10\nXmaj11:\t\tI=0         \tIII=4 \tIV=5\tV=7 \t\t\tVII=11\n------------------------------------------------------------------\nX13: \t\tI=0         \tIII=4 \t    \tV=7 \tVI=9\tVII=10\nXflat13:\tI=0         \tIII=4 \t    \t    \tVI=8\t\nXmin13:\t\tI=0         \tIII=3 \t\t    V=7 \tVI=9\tVII=10\nX-13:\t\tI=0         \tIII=3 \t\t    V=7 \tVI=9\tVII=10\nXmaj13:\t\tI=0         \tIII=4 \t\t    V=7 \tVI=9\tVII=11"}, {"path": "lua/com/com.lua", "data": "local _inspect = require \"lua/com/inspect\"\n\nlocal MidiSchluesselCOffset = 60\nParameterValueNoTag = '__noTagValue'\n\nfunction istable(t) return type(t) == 'table' end\nfunction isnumber(t) return type(t) == 'number' end\nfunction inspect(x) return print(_inspect(x)) end\nfunction dump(x) print(inspect(x)) end\n\n\nfunction checkLegacyNamedParams(params, ...)\n    local args = table.pack(...)\n    for k, v in pairs(params) do\n        if contains(args, v) then\n            local msg = \"Error: legacy named parameter with the argument '\" ..  v .. \"'. \"\n            msg = msg .. \" Use this expression instead: _\" .. v .. \"=...\" \n            error(msg)\n        end\n    end\nend\n\n-- returns the minimum amount of semitones between the relative pitches x and y.\n-- e.g.: from c(0) to b(11) = -1\nfunction relpitchdiff(x, y)\n    x = x % 12\n    y = y % 12\n    if math.abs(x-y) < 6 then\n        return -(x-y)\n    end\n    if x < 6 then \n        x = x + 12 \n    end\n    if y < 6 then\n        y = y + 12\n    end\n    return -(x-y)\nend\n\n-- [a, 1, b, 2, c, 3] => {a=1, b=2, c=3}\n-- @deprecated use the native named parameter feature: _name=value\nfunction tokeyvalue(args)\n    assert(#args % 2 == 0)\n    local result = {}\n    for i=1, #args, 2 do\n        result[ args[i] ] = args[i+1]\n    end\n    return result\nend\n\nfunction toMidiPitch(pitch)\n    return MidiSchluesselCOffset + pitch.pitch + (pitch.octave * 12)\nend\n\nfunction deepcopy(o, seen)\n    seen = seen or {}\n    if o == nil then return nil end\n    if seen[o] then return seen[o] end\n  \n    local no\n    if type(o) == 'table' then\n      no = {}\n      seen[o] = no\n  \n      for k, v in next, o, nil do\n        no[deepcopy(k, seen)] = deepcopy(v, seen)\n      end\n      setmetatable(no, deepcopy(getmetatable(o), seen))\n    else -- number, string, boolean, etc\n      no = o\n    end\n    return no\nend\n\nfunction contains(table, value)\n    if table == nil then\n        return false\n    end\n    for k, v in pairs(table) do\n        if v == value then\n            return true\n        end\n    end\n    return false\nend\n\n-- https://stackoverflow.com/questions/1426954/split-string-in-lua#1426970\nfunction split(pString, pPattern)\n    local Table = {}  -- NOTE: use {n = 0} in Lua-5.0\n    local fpat = \"(.-)\" .. pPattern\n    local last_end = 1\n    local s, e, cap = pString:find(fpat, 1)\n    while s do\n       if s ~= 1 or cap ~= \"\" then\n      table.insert(Table,cap)\n       end\n       last_end = e+1\n       s, e, cap = pString:find(fpat, last_end)\n    end\n    if last_end <= #pString then\n       cap = pString:sub(last_end)\n       table.insert(Table, cap)\n    end\n    return Table\n end"}, {"path": "lua/com/globals.lua", "data": "I   = 1\nII  = 2\nIII = 3\nIV  = 4\nV   = 5\nVI  = 6\nVII = 7\n\nDegreeStringValues = {\n    I   = I,\n    II  = II,\n    III = III,\n    IV  = IV,\n    V   = V,\n    VI  = VI,\n    VII = VII\n}\n\nMajorScaleSemitones = {\n    I   = 0,\n    II  = 2,\n    III = 4,\n    IV  = 5,\n    V   = 7,\n    VI  = 9,\n    VII = 11\n}\n\nC   = 0\nCIS = 1\nDES = 1\nD   = 2\nDIS = 3\nES  = 3\nE   = 4\nFES = 4\nF   = 5\nFIS = 6\nGES = 6\nG   = 7\nGIS = 8\nAS  = 8\nA   = 9\nAIS = 10\nBES = 10\nB   = 11\nCES = 11\n"}, {"path": "lua/com/inspect.lua", "data": "local inspect ={\n  _VERSION = 'inspect.lua 3.1.0',\n  _URL     = 'http://github.com/kikito/inspect.lua',\n  _DESCRIPTION = 'human-readable representations of tables',\n  _LICENSE = [[\n    MIT LICENSE\n\n    Copyright (c) 2013 Enrique Garc\u00eda Cota\n\n    Permission is hereby granted, free of charge, to any person obtaining a\n    copy of this software and associated documentation files (the\n    \"Software\"), to deal in the Software without restriction, including\n    without limitation the rights to use, copy, modify, merge, publish,\n    distribute, sublicense, and/or sell copies of the Software, and to\n    permit persons to whom the Software is furnished to do so, subject to\n    the following conditions:\n\n    The above copyright notice and this permission notice shall be included\n    in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n  ]]\n}\n\nlocal tostring = tostring\n\ninspect.KEY       = setmetatable({}, {__tostring = function() return 'inspect.KEY' end})\ninspect.METATABLE = setmetatable({}, {__tostring = function() return 'inspect.METATABLE' end})\n\nlocal function rawpairs(t)\n  return next, t, nil\nend\n\n-- Apostrophizes the string if it has quotes, but not aphostrophes\n-- Otherwise, it returns a regular quoted string\nlocal function smartQuote(str)\n  if str:match('\"') and not str:match(\"'\") then\n    return \"'\" .. str .. \"'\"\n  end\n  return '\"' .. str:gsub('\"', '\\\\\"') .. '\"'\nend\n\n-- \\a => '\\\\a', \\0 => '\\\\0', 31 => '\\31'\nlocal shortControlCharEscapes = {\n  [\"\\a\"] = \"\\\\a\",  [\"\\b\"] = \"\\\\b\", [\"\\f\"] = \"\\\\f\", [\"\\n\"] = \"\\\\n\",\n  [\"\\r\"] = \"\\\\r\",  [\"\\t\"] = \"\\\\t\", [\"\\v\"] = \"\\\\v\"\n}\nlocal longControlCharEscapes = {} -- \\a => nil, \\0 => \\000, 31 => \\031\nfor i=0, 31 do\n  local ch = string.char(i)\n  if not shortControlCharEscapes[ch] then\n    shortControlCharEscapes[ch] = \"\\\\\"..i\n    longControlCharEscapes[ch]  = string.format(\"\\\\%03d\", i)\n  end\nend\n\nlocal function escape(str)\n  return (str:gsub(\"\\\\\", \"\\\\\\\\\")\n             :gsub(\"(%c)%f[0-9]\", longControlCharEscapes)\n             :gsub(\"%c\", shortControlCharEscapes))\nend\n\nlocal function isIdentifier(str)\n  return type(str) == 'string' and str:match( \"^[_%a][_%a%d]*$\" )\nend\n\nlocal function isSequenceKey(k, sequenceLength)\n  return type(k) == 'number'\n     and 1 <= k\n     and k <= sequenceLength\n     and math.floor(k) == k\nend\n\nlocal defaultTypeOrders = {\n  ['number']   = 1, ['boolean']  = 2, ['string'] = 3, ['table'] = 4,\n  ['function'] = 5, ['userdata'] = 6, ['thread'] = 7\n}\n\nlocal function sortKeys(a, b)\n  local ta, tb = type(a), type(b)\n\n  -- strings and numbers are sorted numerically/alphabetically\n  if ta == tb and (ta == 'string' or ta == 'number') then return a < b end\n\n  local dta, dtb = defaultTypeOrders[ta], defaultTypeOrders[tb]\n  -- Two default types are compared according to the defaultTypeOrders table\n  if dta and dtb then return defaultTypeOrders[ta] < defaultTypeOrders[tb]\n  elseif dta     then return true  -- default types before custom ones\n  elseif dtb     then return false -- custom types after default ones\n  end\n\n  -- custom types are sorted out alphabetically\n  return ta < tb\nend\n\n-- For implementation reasons, the behavior of rawlen & # is \"undefined\" when\n-- tables aren't pure sequences. So we implement our own # operator.\nlocal function getSequenceLength(t)\n  local len = 1\n  local v = rawget(t,len)\n  while v ~= nil do\n    len = len + 1\n    v = rawget(t,len)\n  end\n  return len - 1\nend\n\nlocal function getNonSequentialKeys(t)\n  local keys, keysLength = {}, 0\n  local sequenceLength = getSequenceLength(t)\n  for k,_ in rawpairs(t) do\n    if not isSequenceKey(k, sequenceLength) then\n      keysLength = keysLength + 1\n      keys[keysLength] = k\n    end\n  end\n  table.sort(keys, sortKeys)\n  return keys, keysLength, sequenceLength\nend\n\nlocal function countTableAppearances(t, tableAppearances)\n  tableAppearances = tableAppearances or {}\n\n  if type(t) == 'table' then\n    if not tableAppearances[t] then\n      tableAppearances[t] = 1\n      for k,v in rawpairs(t) do\n        countTableAppearances(k, tableAppearances)\n        countTableAppearances(v, tableAppearances)\n      end\n      countTableAppearances(getmetatable(t), tableAppearances)\n    else\n      tableAppearances[t] = tableAppearances[t] + 1\n    end\n  end\n\n  return tableAppearances\nend\n\nlocal copySequence = function(s)\n  local copy, len = {}, #s\n  for i=1, len do copy[i] = s[i] end\n  return copy, len\nend\n\nlocal function makePath(path, ...)\n  local keys = {...}\n  local newPath, len = copySequence(path)\n  for i=1, #keys do\n    newPath[len + i] = keys[i]\n  end\n  return newPath\nend\n\nlocal function processRecursive(process, item, path, visited)\n  if item == nil then return nil end\n  if visited[item] then return visited[item] end\n\n  local processed = process(item, path)\n  if type(processed) == 'table' then\n    local processedCopy = {}\n    visited[item] = processedCopy\n    local processedKey\n\n    for k,v in rawpairs(processed) do\n      processedKey = processRecursive(process, k, makePath(path, k, inspect.KEY), visited)\n      if processedKey ~= nil then\n        processedCopy[processedKey] = processRecursive(process, v, makePath(path, processedKey), visited)\n      end\n    end\n\n    local mt  = processRecursive(process, getmetatable(processed), makePath(path, inspect.METATABLE), visited)\n    if type(mt) ~= 'table' then mt = nil end -- ignore not nil/table __metatable field\n    setmetatable(processedCopy, mt)\n    processed = processedCopy\n  end\n  return processed\nend\n\n\n\n-------------------------------------------------------------------\n\nlocal Inspector = {}\nlocal Inspector_mt = {__index = Inspector}\n\nfunction Inspector:puts(...)\n  local args   = {...}\n  local buffer = self.buffer\n  local len    = #buffer\n  for i=1, #args do\n    len = len + 1\n    buffer[len] = args[i]\n  end\nend\n\nfunction Inspector:down(f)\n  self.level = self.level + 1\n  f()\n  self.level = self.level - 1\nend\n\nfunction Inspector:tabify()\n  self:puts(self.newline, string.rep(self.indent, self.level))\nend\n\nfunction Inspector:alreadyVisited(v)\n  return self.ids[v] ~= nil\nend\n\nfunction Inspector:getId(v)\n  local id = self.ids[v]\n  if not id then\n    local tv = type(v)\n    id              = (self.maxIds[tv] or 0) + 1\n    self.maxIds[tv] = id\n    self.ids[v]     = id\n  end\n  return tostring(id)\nend\n\nfunction Inspector:putKey(k)\n  if isIdentifier(k) then return self:puts(k) end\n  self:puts(\"[\")\n  self:putValue(k)\n  self:puts(\"]\")\nend\n\nfunction Inspector:putTable(t)\n  if t == inspect.KEY or t == inspect.METATABLE then\n    self:puts(tostring(t))\n  elseif self:alreadyVisited(t) then\n    self:puts('<table ', self:getId(t), '>')\n  elseif self.level >= self.depth then\n    self:puts('{...}')\n  else\n    if self.tableAppearances[t] > 1 then self:puts('<', self:getId(t), '>') end\n\n    local nonSequentialKeys, nonSequentialKeysLength, sequenceLength = getNonSequentialKeys(t)\n    local mt                = getmetatable(t)\n\n    self:puts('{')\n    self:down(function()\n      local count = 0\n      for i=1, sequenceLength do\n        if count > 0 then self:puts(',') end\n        self:puts(' ')\n        self:putValue(t[i])\n        count = count + 1\n      end\n\n      for i=1, nonSequentialKeysLength do\n        local k = nonSequentialKeys[i]\n        if count > 0 then self:puts(',') end\n        self:tabify()\n        self:putKey(k)\n        self:puts(' = ')\n        self:putValue(t[k])\n        count = count + 1\n      end\n\n      if type(mt) == 'table' then\n        if count > 0 then self:puts(',') end\n        self:tabify()\n        self:puts('<metatable> = ')\n        self:putValue(mt)\n      end\n    end)\n\n    if nonSequentialKeysLength > 0 or type(mt) == 'table' then -- result is multi-lined. Justify closing }\n      self:tabify()\n    elseif sequenceLength > 0 then -- array tables have one extra space before closing }\n      self:puts(' ')\n    end\n\n    self:puts('}')\n  end\nend\n\nfunction Inspector:putValue(v)\n  local tv = type(v)\n\n  if tv == 'string' then\n    self:puts(smartQuote(escape(v)))\n  elseif tv == 'number' or tv == 'boolean' or tv == 'nil' or\n         tv == 'cdata' or tv == 'ctype' then\n    self:puts(tostring(v))\n  elseif tv == 'table' then\n    self:putTable(v)\n  else\n    self:puts('<', tv, ' ', self:getId(v), '>')\n  end\nend\n\n-------------------------------------------------------------------\n\nfunction inspect.inspect(root, options)\n  options       = options or {}\n\n  local depth   = options.depth   or math.huge\n  local newline = options.newline or '\\n'\n  local indent  = options.indent  or '  '\n  local process = options.process\n\n  if process then\n    root = processRecursive(process, root, {}, {})\n  end\n\n  local inspector = setmetatable({\n    depth            = depth,\n    level            = 0,\n    buffer           = {},\n    ids              = {},\n    maxIds           = {},\n    newline          = newline,\n    indent           = indent,\n    tableAppearances = countTableAppearances(root)\n  }, Inspector_mt)\n\n  inspector:putValue(root)\n\n  return table.concat(inspector.buffer)\nend\n\nsetmetatable(inspect, { __call = function(_, ...) return inspect.inspect(...) end })\n\nreturn inspect\n"}, {"path": "lua/com/tests.lua", "data": "require \"com/com\"\nrequire \"com/globals\"\n\nfunction testpitchdiff(a, b, expected)\n    local diff = relpitchdiff(a, b)\n    if diff ~= expected then\n        print(\"pitchdiff: \" .. a .. \"-\" .. b .. \"~=\" .. expected .. \"(\" .. diff .. \")\" )\n    end\nend\n\ntestpitchdiff( 0,  0,   0)\ntestpitchdiff( 0,  5,   5)\ntestpitchdiff( 5,  0,  -5)\ntestpitchdiff( 0,  6,   -6)\ntestpitchdiff( 6,  0,   6)\ntestpitchdiff( 7,  0,   5)\ntestpitchdiff( 0,  7,  -5)\ntestpitchdiff( 7,  1,   6)\ntestpitchdiff( 1,  7,  -6)\ntestpitchdiff( 7, 11,   4)\ntestpitchdiff(11,  7,  -4)\ntestpitchdiff( 0, 10,  -2)\ntestpitchdiff(10,  0,   2)\ntestpitchdiff( 5,  9,   4)\ntestpitchdiff( 9,  5,  -4)\ntestpitchdiff( 5, 11,  -6)\ntestpitchdiff(11,  5,   6)\ntestpitchdiff( 9, 11,   2)\ntestpitchdiff(11,  9,  -2)\ntestpitchdiff(11,  1,   2)\ntestpitchdiff( 1, 11,  -2)\ntestpitchdiff( 12, 24,  0)\n\n\nx = tokeyvalue({\"a\", 100, \"b\", 200, \"c\", 300})\nassert(x.a == 100)\nassert(x.b == 200)\nassert(x.c == 300)\n\n\nassert( toMidiPitch({pitch=C,   octave=0}) == 60)\nassert( toMidiPitch({pitch=C,   octave=1}) == 72)\nassert( toMidiPitch({pitch=CIS, octave=1}) == 73)\nassert( toMidiPitch({pitch=C,   octave=-1}) == 48)"}, {"path": "lua/mods/_drumRudimentsRepository.lua", "data": "-- A definition of drum rudiments.\n-- The actual rudiment duration dosen't matter. At the end, the sequence\n-- will be ajdusted, so that it fits into the duration of the related event.\n-- The relations between the different durations is what matters.\n-- For example\n-- A rudiment with four quarters, played over the duration of one eight:\n-- every rudiment quarter will become eventually a 32th\nR=\"R\"\nL=\"L\"\n\nFlamType = \"flam\"\nDragType = \"drag\"\n\n-- durations\nlocal _4    = 1\nlocal _8    = 1/2\nlocal _16   = 1/4\nlocal _32   = 1/8 \nlocal _4t   = _4 / 3\nlocal _8t   = _8 / 3\nlocal _16t  = _16 / 3\nlocal _32t  = _32 / 3\n-- velocity factors\nAccent      = \"accent\"\nUnaccented  = \"unaccented\"\nGraceNote   = \"grace note\"\n\nlocal ac = Accent\nlocal un = Unaccented\n\n\n-- create a rudiment sequence event\nlocal function Stroke(which, duration, velocityClass)\n    if velocityClass == nil then\n        velocityClass = Accent\n    end\n    return { which=which, duration=duration, velocityClass = velocityClass }\nend\n\nlocal function Flam(which, duration, velocityClass)\n    if velocityClass == nil then\n        velocityClass = Accent\n    end\n    return { which=which, duration=duration, velocityClass = velocityClass, type = FlamType}\nend\n\nlocal function Drag(which, duration, velocityClass)\n    if velocityClass == nil then\n        velocityClass = Accent\n    end\n    return { which=which, duration=duration, velocityClass = velocityClass, type = DragType}\nend\n\nlocal S = Stroke\n\nlocal function Diddle(which, duration)\n    return {\n        S(which, duration, un), S(which, duration, un)\n    }\nend\n\n-- returns L for R and R for L.\nfunction Alt(which)\n    if which == L then\n        return R\n    elseif which == R then\n        return L\n    end\n    return nil\nend\n\n-- alternates the \"Hand\" value (which).\n-- \"L\" -> \"R\"\n-- \"R\" -> \"L\"\nfunction AlternateEvent(event)\n    local copy = deepcopy(event)\n    copy.which = Alt(event.which)\n    return copy\nend\n\n-- Creates a alternating stroke sequence RL...n or LR...n.\n-- @param startingEvent: the first event. All further created events are unaccented.\n-- @param numberOfPerformances: the number of the total performances. One RL means one performance.\nlocal function Alternate(startingEvent, numberOfPerformances)\n    if numberOfPerformances == nil then\n        numberOfPerformances = 1\n    end\n    local result = {startingEvent}\n    local which = startingEvent.which\n    for i = 0, (numberOfPerformances-1)*2, 1 do\n        which = Alt(which)\n        table.insert(result, S(which, startingEvent.duration, un))\n    end\n    return result\nend\n\n-- Creates a sequence of variable args.\n-- An argument can be either a array of events or a single event\nlocal function Seq(...)\n    local args = table.pack(...)\n    local result = {}\n    for i=1,args.n do\n        local arg = args[i]\n        local isEvent = arg.which ~= nil\n        if isEvent then\n            table.insert(result, arg)\n        else\n            for key, event in pairs(arg) do\n                table.insert(result, event)\n            end\n        end\n    end\n    return result\nend\n\nRudiments = {\n    [\"singleStrokeRoll\"] =\n        { S(R, _4), S(L, _4) },\n    [\"doubleStrokeRoll\"] =\n        { S(R, _4), S(R, _4), S(L, _4), S(L, _4) },\n    [\"trippleStrokeRoll\"] =\n        { S(R, _4), S(R, _4), S(R, _4), S(L, _4), S(L, _4), S(L, _4) },\n    [\"fiveStrokeRoll\"] =\n        { S(R, _32, un), S(R, _32, un), S(L, _32, un), S(L, _32, un), S(R, _8, ac) },\n    [\"singleStrokeFour\"] =\n        { S(R, _4t), S(L, _4t), S(R, _4t), S(L, _4) },\n    [\"singleStrokeSeven\"] =\n        { S(R, _8t), S(L, _8t), S(R, _8t), S(L, _8t), S(R, _8t), S(L, _8t), S(R, _4) },\n    [\"multipleBounceRoll\"] =\n        { S(R, _32, un), S(R, _32, un), S(R, _32, un), S(R, _32, un),\n          S(L, _32, un), S(L, _32, un), S(L, _32, un), S(L, _32, un)},\n    [\"sixStrokeRoll\"] =\n        Seq(S(R, _8, ac), Diddle(L, _16), Diddle(R, _16), S(L, _8, ac)),\n    [\"sevenStrokeRoll\"] =\n        Seq(Diddle(L, _16), Diddle(R, _16), Diddle(L, _16), S(R, _8, ac)),\n    [\"nineStrokeRoll\"] =\n        Seq(Diddle(R, _16), Diddle(L, _16), Diddle(R, _16), Diddle(L, _16), S(R, _8, ac)),\n    [\"tenStrokeRoll\"] =\n        Seq(Diddle(R, _16), Diddle(L, _16), Diddle(R, _16), Diddle(L, _16), S(R, _8, ac), S(L, _8, ac)),\n    [\"elevenStrokeRoll\"] =\n        Seq(Diddle(R, _16), Diddle(L, _16), Diddle(R, _16), Diddle(L, _16), Diddle(R, _16), S(L, _8, ac)),\n    [\"thirteenStrokeRoll\"] =\n        Seq(Diddle(R, _16), Diddle(L, _16), Diddle(R, _16), Diddle(L, _16), Diddle(R, _16), Diddle(L, _16), S(R, _8, ac)),\n    [\"fifteenStrokeRoll\"] =\n        Seq(Diddle(R, _16), Diddle(L, _16), Diddle(R, _16), Diddle(L, _16), Diddle(R, _16), Diddle(L, _16), Diddle(R, _16), S(L, _8, ac)),\n    [\"seventeenStrokeRoll\"] =\n        Seq(Diddle(R, _16), Diddle(L, _16), Diddle(R, _16), Diddle(L, _16), Diddle(R, _16), Diddle(L, _16), Diddle(R, _16), Diddle(L, _16), S(R, _8, ac)),\n    [\"paradiddle\"] =\n        Seq(Alternate(S(R, _16, ac)), Diddle(R, _16)),\n    [\"doubleParadiddle\"] =\n        Seq(Alternate(S(R, _16, ac), 2), Diddle(R, _16)),\n    [\"trippleParadiddle\"] =\n        Seq(Alternate(S(R, _16, ac), 3), Diddle(R, _16)),\n    [\"paradiddlediddle\"] =\n        Seq(Alternate(S(R, _16, ac)), Diddle(R, _16), Diddle(L, _16)),\n    [\"flam\"] =\n        Seq(Flam(R, _4)),\n    [\"flamAccent\"] =\n        Seq(Flam(R, _8, ac), S(L, _8, un), S(R, _8, un)),\n    [\"flamTap\"] =\n        Seq(Flam(R, _16, ac), S(R, _16, un)),\n    [\"flamacue\"] =\n        Seq(Flam(R, _16, un), S(L, _16, ac), S(R, _16, un), S(L, _16, un), Flam(R, _4, un)),\n    [\"flamParadiddle\"] =\n        Seq(Flam(R, _16, ac), S(L, _16, un), Diddle(R, _16)),\n    [\"singleFlammedMill\"] =\n        Seq(Flam(R, _16, ac), S(R, _16, un), S(L, _16, un), S(R, _16, un)),\n    [\"pataflafla\"] =\n        Seq(Flam(R, _16, ac), S(L, _16, un), Diddle(R, _16), Flam(L, _16, ac)),\n    [\"swissArmytriplet\"] =\n        Seq(Flam(R, _16t, ac), S(R, _16t, un), S(L, _16t, un)),\n    [\"invertedFlamTap\"] =\n        Seq(Flam(R, _16, ac), S(L, _16, un)),\n    [\"flamDrag\"] =\n        Seq(Flam(R, _8, ac), S(L, _16, un), S(L, _16, un), S(R, _8, un)),\n    [\"drag\"] =\n        Seq(Drag(R, _4, ac)),\n    [\"singleDragTap\"] =\n        Seq(Drag(R, _8, un), S(L, _8, ac)),\n    [\"doubleDragTap\"] =\n        Seq(Drag(R, _8, un), Drag(R, _8, un), S(L, _8, ac)),\n    [\"lesson25\"] =\n        Seq(Drag(R, _16, un), S(L, _16, un), S(R, _8, ac)),\n    [\"singleDragadiddle\"] =\n        Seq(Drag(R, _16, ac), S(L, _16, un), Diddle(R, _16)),\n    [\"dragParadiddle1\"] =\n        Seq(S(R, _8, ac), Drag(R, _16, un), S(L, _16, un), Diddle(R, _16)),\n    [\"dragParadiddle2\"] =\n        Seq(S(R, _8, ac), Drag(R, _8, un), Drag(R, _16, un), S(L, _16, un), Diddle(R, _16)),\n    [\"singleRatamacue\"] =\n        Seq(Drag(R, _8t, un), S(L, _8t, un), S(R, _8t, un), S(L, _8, ac)),\n    [\"doubleRatamacue\"] =\n        Seq(Drag(R, _8, un), Drag(R, _8t, un), S(L, _8t, un), S(R, _8t, un), S(L, _8, ac)),\n    [\"trippleRatamacue\"] =\n        Seq(Drag(R, _8, un), Drag(R, _8, un), Drag(R, _8t, un), S(L, _8t, un), S(R, _8t, un), S(L, _8, ac))        \n}\n"}, {"path": "lua/mods/_events.lua", "data": "\nNote = {}\n\nfunction Note:new()\n    local o = {}\n    setmetatable(o, self)\n    self.__index = self\n    o.duration = 0\n    o.isTied = false\n    o.offset = 0\n    o.pitches = {}\n    o.type = \"note\"\n    o.velocity = 0\n    return o \nend\n\nfunction Note:addPitch(pitch, octave)\n    table.insert(self.pitches, {pitch=pitch, octave=octave})\nend\n\nfunction pitchCompare(a, b)\n    a = a.pitch + (a.octave * 12)\n    b = b.pitch + (b.octave * 12)\n    return a < b\nend\n\nfunction pitchCompareReversed(a, b)\n    a = a.pitch + (a.octave * 12)\n    b = b.pitch + (b.octave * 12)\n    return a > b\nend\n"}, {"path": "lua/mods/drumRudiments.lua", "data": "-- <command name=\"drumRudiments\" where=\"mod\" using=\"lua/mod/drumRudiments.lua\">\n-- <![CDATA[\n-- Implements a collection of different drum rudiments. ([see Wikipedia](https://en.wikipedia.org/wiki/Drum_rudiment))\n-- You can specify which notes are for `L` and `R` and performing duration.\n-- This will be achived by using an chord as source material.\n-- The chord pitches will be used for `L` and `R`.\n-- The length of the chord event defines over which time the rudiment will be peformed.\n-- An event tag specifies which rudiment will be performed.\n-- For example:\n-- This plays one paradiddle over a length of 1 quarter\n-- using `sn1` for R and `sn2` for L:\n-- ```\n-- /mod: drumRudiments/\\n\n--                 R     L \\n\n-- \"paradiddle\"@<\"sn1\" \"sn2\">4\\n\n-- ```\n-- Examples:\n-- **a single paradiddle**\n-- ```language=Werckmeister\\n\n--using \"lua/mods/drumRudiments.lua\";\\n\n--tempo: 150;\\n\n--device: MyDevice  midi 0;\\n\n--instrumentDef:piano  MyDevice  _ch=0 _pc=118;\\n\n--[\\n\n--instrument: piano;\\n\n--{\\n\n--   /mod: drumRudiments/\\n\n--   -- a paradiddle (RLRR) with c' for R and c for L\\n\n--   \"paradiddle\"@<c' c>1\\n\n--}\\n\n--]\\n\n-- ```\n-- **repeating**\n-- ```language=Werckmeister\\n\n--using \"lua/mods/drumRudiments.lua\";\\n\n--tempo: 120;\\n\n--device: MyDevice  midi 0;\\n\n--instrumentDef:piano  MyDevice  _ch=0 _pc=118;\\n\n--[\\n\n--instrument: piano;\\n\n--{\\n\n--   /mod: drumRudiments/\\n\n--   -- performs 4 paradiddles (RLRR LRLL RLRR LRLL) with c' for R and c for L\\n\n--   \"4x paradiddle\"@<c' c>1\\n\n--}\\n\n--]\\n\n-- ```\n-- **orchestration**\n-- If you want to orchestrate a rudiment over a drum set,\n-- you are able to define more R & L notes. *(The total number of the notes has to be even.)*\n-- ```language=Werckmeister\\n\n--using \"lua/mods/drumRudiments.lua\";\\n\n--tempo: 120;\\n\n--device: MyDevice  midi 0;\\n\n--instrumentDef:piano  MyDevice  _ch=0 _pc=118;\\n\n--[\\n\n--instrument: piano;\\n\n--{\\n\n--   /mod: drumRudiments/\\n\n--   -- performs 4 paradiddles (RLRR LRLL RLRR LRLL) with \\n\n--   --      c' for R1 and c for L1\\n\n--   -- and  c, for R2 and c,, for L2.\\n\n--   -- The final sequence will be: c'(R1) c(L1) c,(R2) c,,(R1) ... \\n\n--   \"4x paradiddle\"@<c' c c, c,,>1\n--}\\n\n--]\\n\n-- ```\n-- **Supported Rudiments**\n--<ul style=\"font-size: 0.9em;\">\n--<li>singleStrokeRoll</li>\n--<li>doubleStrokeRoll</li>\n--<li>trippleStrokeRoll</li>\n--<li>fiveStrokeRoll</li>\n--<li>singleStrokeFour</li>\n--<li>singleStrokeSeven</li>\n--<li>multipleBounceRoll</li>\n--<li>sixStrokeRoll</li>\n--<li>sevenStrokeRoll</li>\n--<li>nineStrokeRoll</li>\n--<li>tenStrokeRoll</li>\n--<li>elevenStrokeRoll</li>\n--<li>thirteenStrokeRoll</li>\n--<li>fifteenStrokeRoll</li>\n--<li>seventeenStrokeRoll</li>\n--<li>paradiddle</li>\n--<li>doubleParadiddle</li>\n--<li>trippleParadiddle</li>\n--<li>paradiddlediddle</li>\n--<li>flam</li>\n--<li>flamAccent</li>\n--<li>flamTap</li>\n--<li>flamacue</li>\n--<li>flamParadiddle</li>\n--<li>singleFlammedMill</li>\n--<li>pataflafla</li>\n--<li>swissArmytriplet</li>\n--<li>invertedFlamTap</li>\n--<li>flamDrag</li>\n--<li>singleDragTap</li>\n--<li>doubleDragTap</li>\n--<li>lesson25</li>\n--<li>singleDragadiddle</li>\n--<li>dragParadiddle1</li>\n--<li>dragParadiddle2</li>\n--<li>singleRatamacue</li>\n--<li>doubleRatamacue</li>\n--<li>trippleRatamacue</li>\n--</ul>\n-- ]]>\n-- </command>\n-- <param name=\"velocityFactorAccented\"   optional=\"1\" type=\"0..1\">The velocity factor for accented notes (Default=1)</param>\n-- <param name=\"velocityFactorUnaccented\" optional=\"1\" type=\"0..1\">The velocity factor for unaccented notes (Default=0.7)</param>\n-- <param name=\"velocityFactorGraceNote\"  optional=\"1\" type=\"0..1\">The velocity factor for accented notes (Default=1)</param>\n-- <param name=\"flamOffset\"               optional=\"1\" type=\"0..N\">The offset in quartes when to perform the grace note before the actual note (Default=0.05)</param>\n-- <param name=\"dragOffset\"               optional=\"1\" type=\"0..N\">The offset in quartes when to perform the two grace notes before the actual note (Default=0.05)</param>\n\n\n\nrequire \"lua/com/com\"\nrequire \"_drumRudimentsRepository\"\nrequire \"_events\"\n\nparameters = {\n    { name=\"velocityFactorAccented\",            default=\"1\" },\n    { name=\"velocityFactorUnaccented\",          default=\"0.7\" },\n    { name=\"velocityFactorGraceNote\",           default=\"0.2\" },\n    { name=\"flamOffset\",                        default=\"0.05\" },\n    { name=\"dragOffset\",                        default=\"0.05\" },\n}\n\n\nSupportedRepeatTags = {\n    [\"2x\"]  =  2,\n    [\"3x\"]  =  3,\n    [\"4x\"]  =  4,\n    [\"5x\"]  =  5,\n    [\"6x\"]  =  6,\n    [\"7x\"]  =  7,\n    [\"8x\"]  =  8,\n    [\"9x\"]  =  9,\n    [\"10x\"]  =  10,\n    [\"11x\"] = 11,\n    [\"12x\"] = 12,\n    [\"13x\"] = 13,\n    [\"14x\"] = 14,\n    [\"15x\"] = 15,\n    [\"16x\"] = 16,\n    [\"17x\"] = 17,\n    [\"18x\"] = 18,\n    [\"19x\"] = 19,\n    [\"20x\"] = 20,\n    [\"21x\"] = 21,\n    [\"22x\"] = 22,\n    [\"23x\"] = 23,\n    [\"24x\"] = 24,\n    [\"25x\"] = 25,\n    [\"26x\"] = 26,\n    [\"27x\"] = 27,\n    [\"28x\"] = 28,\n    [\"29x\"] = 29,\n    [\"30x\"] = 30,\n    [\"31x\"] = 31,\n    [\"32x\"] = 32,\n}\n\nlocal tiedEventCache = {\n    [\"offset\"] = 0,\n    [\"duration\"] = 0,\n    [\"originEvent\"] = nil\n}\n\nlocal function newTiedEventCache(event)\n    tiedEventCache.duration = event.duration\n    tiedEventCache.originEvent = event\nend\n\nlocal function isTiedEventCacheEmpty()\n    return tiedEventCache.originEvent == nil\nend\n\nlocal function clearTiedEventCache()\n    tiedEventCache.originEvent = nil\n    tiedEventCache.duration = 0\n    tiedEventCache.offset = 0\nend\n\nlocal function getPossibleRudimentEvent(events)\n    local firstEvent = events[1]\n    if not isTiedEventCacheEmpty() then\n        tiedEventCache.duration = tiedEventCache.duration + firstEvent.duration\n        tiedEventCache.offset = tiedEventCache.offset - firstEvent.duration\n        if firstEvent.isTied then\n            return nil\n        end\n    end\n    if not isTiedEventCacheEmpty() and not firstEvent.isTied then\n        firstEvent = tiedEventCache.originEvent\n        firstEvent.isTied = false\n        firstEvent.offset = tiedEventCache.offset\n        firstEvent.duration = tiedEventCache.duration\n        clearTiedEventCache()\n    end\n    return firstEvent\nend\n\n\nfunction perform(events, params, timeinfo)\n    local firstEvent = getPossibleRudimentEvent(events)\n    if (firstEvent == nil) then\n        return {}\n    end\n    if #events == 0 or #firstEvent.tags == 0 then\n        return events\n    end\n    if firstEvent.duration == 0 then\n        return events\n    end\n    local rudimentPerformer = RudimentPerformer:new()\n    rudimentPerformer.velocityFactorAccented = tonumber(params.velocityFactorAccented)\n    rudimentPerformer.velocityFactorUnaccented = tonumber(params.velocityFactorUnaccented)\n    rudimentPerformer.velocityFactorGraceNote = tonumber(params.velocityFactorGraceNote)\n    rudimentPerformer.flamOffset = tonumber(params.flamOffset)\n    rudimentPerformer.dragOffset = tonumber(params.dragOffset)\n    rudimentPerformer:setSourceEvent(firstEvent)\n    if rudimentPerformer.rudiment == nil then\n        return events\n    end\n    if firstEvent.isTied then\n        newTiedEventCache(firstEvent)\n        return {}\n    end\n    local rudimentEvents = rudimentPerformer:perform();\n    return rudimentEvents\nend\n\nRudimentPerformer = {}\nfunction RudimentPerformer:new(o)\n    local o = o or {}\n    setmetatable(o, self)\n    self.__index = self\n    self.idxL = 1\n    self.idxR = 1\n    self.offset = 0\n    self.velocityFactorAccented = 1\n    self.velocityFactorUnaccented = 0.7\n    self.velocityFactorGraceNote = 0.2\n    self.flamOffset = 0.05\n    self.dragOffset = 0.05\n    return o\nend\n\nfunction RudimentPerformer:findRudimentName(tags)\n    for idx, tag in pairs(tags) do\n        local val = Rudiments[tag]\n        if val ~= nil then\n            return tag\n        end\n    end\n    return nil\nend\n\nfunction RudimentPerformer:findRepeatTagValue(tags)\n    for idx, tag in pairs(tags) do\n        local val = SupportedRepeatTags[tag]\n        if val ~= nil then\n            return val\n        end\n    end\n    return nil\nend\n\nfunction RudimentPerformer:setSourceEvent(event)\n    local rudimentName = self:findRudimentName(event.tags)\n    local source       = event.pitches\n    self.offset        = event.offset\n    self.rudiment = Rudiments[rudimentName]\n    if self.rudiment == nil then\n        return\n    end\n    if #source % 2 ~= 0 then\n        -- not enough events\n        error(\"not enough chord pitches for rudiment \" .. rudimentName)\n    end\n    local repeatCount = self:findRepeatTagValue(event.tags)\n    if repeatCount ~= nil then\n        self:repeat_(repeatCount)\n    end\n    self.duration = event.duration\n    self.ls = {}\n    self.rs = {}\n    self.velocity = event.velocity\n    for idx, pitch in pairs(source) do\n        if idx % 2 == 0 then\n            table.insert(self.ls, pitch)\n        else\n            table.insert(self.rs, pitch)\n        end\n    end\nend\n\nfunction RudimentPerformer:repeat_(count)\n    local sequence = {}\n    for i=1,count do\n        local useAlternation = i % 2 == 1\n        for idx, rudimentEvent in pairs(self.rudiment) do\n            local event = rudimentEvent\n            if (useAlternation) then\n                event = AlternateEvent(event)\n            end\n            table.insert(sequence, event)\n        end\n    end\n    self.rudiment = sequence\nend\n\nfunction RudimentPerformer:l()\n    local l = self.ls[self.idxL]\n    self.idxL = self.idxL + 1\n    if self.idxL > #self.ls then\n        self.idxL = 1\n    end\n    return l\nend\n\nfunction RudimentPerformer:r()\n    local r = self.rs[self.idxR]\n    self.idxR = self.idxR + 1\n    if self.idxR > #self.ls then\n        self.idxR = 1\n    end\n    return r\nend\n\nfunction RudimentPerformer:nextPitch(lOrR)\n    if lOrR == nil then\n        error(\"invalid L R value for rudiment: nil\")\n    end\n    if lOrR == L then\n        return self:l()\n    elseif lOrR == R then\n        return self:r()\n    end\n    error(\"invalid L R value for rudiment: \" .. lOrR)\nend\n\n-- duration of the rudiment definition\nfunction RudimentPerformer:defDuration()\n    local duration = 0\n    for idx, rudiment in pairs(self.rudiment) do\n        duration = duration + rudiment.duration\n    end\n    return duration\nend\n\nfunction RudimentPerformer:getVelocityFactor(rudiment)\n    if rudiment.velocityClass == Accent then\n        return self.velocityFactorAccented\n    end\n    if rudiment.velocityClass == Unaccented then\n        return self.velocityFactorUnaccented\n    end\n    if rudiment.velocityClass == GraceNote then\n        return self.velocityFactorGraceNote\n    end\n    error(\"no velocity value for class \" .. rudiment.velocityClass)\nend\n\nfunction RudimentPerformer:perform()\n    local events = {}\n    local offset = self.offset\n    local durationFactor = self.duration / self:defDuration()\n    for idx, rudiment in pairs(self.rudiment) do\n        local type           = rudiment.type\n        local which          = rudiment.which\n        local duration       = rudiment.duration\n        local velocityFactor = self:getVelocityFactor(rudiment)\n        local note = Note:new()\n        note.duration = duration * durationFactor\n        note.velocity = self.velocity * velocityFactor\n        note.offset = offset\n        local pitch = self:nextPitch(which)\n        note:addPitch(pitch.pitch, pitch.octave)\n        if type == FlamType then\n            self:performFlam(events, note, Alt(which))\n        end\n        if type == DragType then\n            self:performDrag(events, note, Alt(which))\n        end        \n        table.insert(events, note)\n        offset = offset + note.duration\n    end\n    return events\nend\n\n\nfunction RudimentPerformer:performFlam(events, note, which)\n    local flamDuration = self.flamOffset\n    local flam = Note:new()\n    local pitch = self:nextPitch(which)\n    flam:addPitch(pitch.pitch, pitch.octave)\n    flam.duration = flamDuration\n    flam.velocity = note.velocity * self.velocityFactorGraceNote\n    flam.offset = note.offset\n    note.offset = note.offset + flamDuration\n    note.duration = note.duration\n    table.insert(events, flam)\nend\n\nfunction RudimentPerformer:performDrag(events, note, which)\n    local flamDuration = self.dragOffset\n    local pitch = self:nextPitch(which)\n    local flam = Note:new()\n    flam:addPitch(pitch.pitch, pitch.octave)\n    flam.duration = flamDuration\n    flam.velocity = note.velocity * self.velocityFactorGraceNote\n    flam.offset = note.offset\n    table.insert(events, flam)\n\n    flam = Note:new()\n    flam:addPitch(pitch.pitch, pitch.octave)\n    flam.duration = flamDuration\n    flam.velocity = note.velocity * self.velocityFactorGraceNote\n    flam.offset = note.offset + flamDuration\n    table.insert(events, flam)\n\n    note.offset = note.offset + flamDuration * 2\n    note.duration = note.duration\n\nend\n"}, {"path": "lua/mods/guitarStroke.lua", "data": "-- <command name=\"guitarStroke\" where=\"mod\" using=\"lua/mod/guitarStroke.lua\">\n-- <![CDATA[\n-- Simulates guitar strokes as mini arpeggios.\n-- *Note: the alternate mode works only if this mod is set via instrumentConf.*\n-- ```\n-- -- does not work: \\n\n-- [ \\n\n-- { \\n\n--   /mod: guitarStroke _mode=alternate/\\n\n-- } \\n\n-- ] \\n\n-- ```\n-- ```\n-- -- does work: \\n\n-- instrumentConf: myInstrument mod guitarStroke _mode=alternate; \\n\n-- ```\n-- **Example**\n-- ```language=Werckmeister\\n\n--using \"lua/mods/guitarStroke.lua\";\\n\n--tempo: 120;\\n\n--device: MyDevice  midi 0;\\n\n--instrumentDef:  piano  MyDevice  _ch=0 _pc=24;\\n\n--instrumentConf: piano mod guitarStroke _mode=alternate _value=16; \\n\n--[\\n\n--instrument: piano;\\n\n--{\\n\n--  <c e g b>4 <c e g b>4 <c eb g bb>2 |  <c eb g bb>2 <c eb g bb>2\\n\n--}\\n\n--]\\n\n-- ```\n-- ]]>\n-- </command>\n-- <param name=\"direction\" optional=\"1\" type=\"[up,down]\">Specifies the start direction of the stroke</param>\n-- <param name=\"value\" optional=\"1\" type=\"[1,2,4,8,...]\">the duration of one aprgeggio event. (Default=64)</param>\n-- <param name=\"mode\" optional=\"1\" type=\"[normal,alternate]\">Perform only one stroke direction (normal) or alternates between up and down. (Default=normal)</param>\n\nrequire \"lua/com/com\"\nrequire \"_events\"\n\n\nparameters = {\n    -- can be up, down\n    { name=\"direction\",       default=\"up\" },\n    -- can be 1, 2, 4, 8, 16, 32, 64, ...\n    { name=\"value\",           default=\"64\" },\n    -- can be normal, alternate\n    { name=\"mode\",            default=\"normal\" }\n\n}\n\nlocal direction = nil\nlocal mode = nil\n\nfunction perform(eventsOrigin, params, timeinfo)\n    if #eventsOrigin > 2 then\n        return eventsOrigin\n    end\n    checkLegacyNamedParams(params, \"direction\", \"mode\", \"value\")\n    local directionParam = params.direction\n    local modeParam      = params.mode\n    local value          = params.value\n    value = tonumber(value)\n    local event = eventsOrigin[1]\n    local events = { }\n    local comparer = pitchCompare\n    \n    if mode == nil then\n        mode = modeParam\n    end\n\n    if direction ==nil then\n        direction = directionParam\n    end\n\n    if direction == \"down\" then\n        comparer = pitchCompareReversed\n        if mode == \"alternate\" then\n            direction = \"up\"\n        end\n    else\n        comparer = pitchCompare\n        if mode == \"alternate\" then\n            direction = \"down\"\n        end\n    end\n\n    local duration = 1 / value\n    table.sort( event.pitches, comparer)\n    for i, pitch in pairs(event.pitches) do\n        local note = Note:new()\n        local newOffset = event.offset + (i-1) * duration\n        note.offset = newOffset\n        note.duration = event.duration - newOffset\n        note.isTied = event.isTied\n        note.velocity = event.velocity\n        note:addPitch(pitch.pitch, pitch.octave)\n        table.insert(events, note)   \n    end\n    return events\nend"}, {"path": "lua/mods/legato.lua", "data": "-- <command name=\"legato\" where=\"mod\" using=\"lua/mod/legato.lua\">\n-- Performs every note legato. It is also possible to tag single notes.\n-- If a tag is given, only the tagged notes are performed legato.\n-- ```language=Werckmeister\\n\n--using \"lua/mods/legato.lua\";\\n\n--tempo: 140;\\n\n--device: MyDevice  midi 0;\\n\n--instrumentDef:piano  MyDevice  _ch=0 _pc=0;\\n\n--[\\n\n--instrument: piano;\\n\n--{\\n\n--   /mod: legato _forTag=leg _amount=100/\\n\n--   -- only the `d` will be performed legato. \\n\n--   c \"leg\"@d e f\\n\n--}\\n\n--]\\n\n-- ```\n-- </command>\n-- <param name=\"forTag\" optional=\"1\" type=\"word\">Specifies a tag name. If set only events with this tag name will be affected by the legato mod.</param>\n-- <param name=\"amount\" optional=\"1\" type=\"0..100\">The ammount of the legato effect</param>\n\nrequire \"lua/com/com\"\n\nlocal defaultAmountValue = 50\n\nparameters = {\n    -- specify a tag name. If set only events with this tag name will be affected by the staccato mod. \n    { name=\"forTag\", default=ParameterValueNoTag },\n    -- the ammount of the staccato mod. Can be between 0 and 100\n    { name=\"amount\",           default=\"50\" }\n}\n\nfunction perform(events, params, timeinfo) \n    checkLegacyNamedParams(params, \"forTag\", \"amount\")\n    local tag = params.forTag\n    if tag == ParameterValueNoTag then\n        tag = nil\n    end\n    local amount = tonumber(params.amount)\n    local factor = 100 - ((amount/100) * 90)\n    factor = factor / 100\n    for i, event in pairs(events) do\n        if tag == nil or contains(event.tags, tag) then\n            event.duration = event.duration / factor\n        end\n    end\n    return events\nend"}, {"path": "lua/mods/myArpeggio.lua", "data": "-- <command name=\"myArpeggio\" where=\"mod\" using=\"lua/mod/myArpeggio.lua\">\n-- <![CDATA[\n-- A simple arpeggio implementation.\n-- **Example**\n-- ```language=Werckmeister\\n\n--using \"lua/mods/myArpeggio.lua\";\\n\n--tempo: 120;\\n\n--device: MyDevice  midi 0;\\n\n--instrumentDef:  piano  MyDevice  _ch=0 _pc=0;\\n\n--[\\n\n--instrument: piano;\\n\n--{\\n\n-- /do: myArpeggio/ \\n\n-- <c e g b>2 \\n\n-- /do: myArpeggio _direction=down/ \\n\n-- <c eb g bb>2 \\n\n--}\\n\n--]\\n\n-- ```\n-- ]]>\n-- </command>\n-- <param name=\"style\" optional=\"1\" type=\"[normal,legato]\">Performs the arpeggio normal or legato</param>\n-- <param name=\"direction\" optional=\"1\" type=\"[up,down]\">the direction of the aprgeggio. (Default=up)</param>\n\nrequire \"lua/com/com\"\nrequire \"_events\"\n\n\nparameters = {\n    -- can be legato, normal\n    { name=\"style\",           default=\"normal\" },\n    -- can be up, down\n    { name=\"direction\",       default=\"up\" }\n}\n\nfunction perform(eventsOrigin, params, timeinfo)\n    checkLegacyNamedParams(params, \"direction\", \"style\")\n    local event     = eventsOrigin[1]\n    local events    = { }\n    local comparer  = pitchCompare\n    local direction = params.direction\n    local style     = params.style\n\n    if direction == \"down\" then\n        comparer = pitchCompareReversed\n    end\n    local duration = event.duration / #event.pitches\n    table.sort( event.pitches, comparer)\n    for i, pitch in pairs(event.pitches) do\n        local note = Note:new()\n        note.duration = duration\n        if style == \"legato\" then\n            note.duration = event.duration\n        end\n        note.velocity = event.velocity\n        note.offset = (i-1) * duration\n        note.isTied = event.isTied\n        note:addPitch(pitch.pitch, pitch.octave)\n        table.insert(events, note)   \n    end\n    return events\nend"}, {"path": "lua/mods/staccato.lua", "data": "-- <command name=\"staccato\" where=\"mod\" using=\"lua/mod/staccato.lua\">\n-- Performs every note staccato. It is also possible to tag single notes.\n-- If a tag is given, only the tagged notes are performed staccato.\n-- ```language=Werckmeister\\n\n--using \"lua/mods/staccato.lua\";\\n\n--tempo: 140;\\n\n--device: MyDevice  midi 0;\\n\n--instrumentDef:piano  MyDevice  _ch=0 _pc=0;\\n\n--[\\n\n--instrument: piano;\\n\n--{\\n\n--   /mod: staccato _forTag=stac _amount=100/\\n\n--   -- only the `d` will be performed staccato. \\n\n--   c \"stac\"@d e f\\n\n--}\\n\n--]\\n\n-- ``` \n-- </command>\n-- <param name=\"forTag\" optional=\"1\" type=\"word\">Specifies a tag name. If set only events with this tag name will be affected by the staccato mod.</param>\n-- <param name=\"amount\" optional=\"1\" type=\"0..100\">The ammount of the staccato effect</param>\n\nrequire \"lua/com/com\"\n\n\nparameters = {\n    -- specify a tag name. If set only events with this tag name will be affected by the staccato mod. \n    { name=\"forTag\", default=ParameterValueNoTag },\n    -- the ammount of the staccato mod. Can be between 0 and 100\n    { name=\"amount\",           default=\"50\" }\n}\n\nfunction perform(events, params, timeinfo)\n    checkLegacyNamedParams(params, \"forTag\", \"amount\")\n    local tag = params.forTag\n    if tag == ParameterValueNoTag then\n        tag = nil\n    end\n    local amount = tonumber(params.amount)\n    local factor = 100 - ((amount/100) * 90)\n    factor = factor / 100\n    for i, event in pairs(events) do\n        if tag == nil or contains(event.tags, tag) then\n            event.duration = event.duration * factor\n        end\n    end\n    return events\nend"}, {"path": "lua/mods/swing.lua", "data": "-- <command name=\"swing\" where=\"mod\" using=\"lua/mod/swing.lua\">\n-- Performs a swing groove.\n-- ```language=Werckmeister\\n\n--using \"lua/mods/swing.lua\";\\n\n--tempo: 120;\\n\n--device: MyDevice  midi 0;\\n\n--instrumentDef:  piano  MyDevice  _ch=0 _pc=0;\\n\n--[\\n\n--instrument: piano;\\n\n--{\\n\n--   /mod: swing/\\n\n--   c8  c   c   c   c   c   c   c\n--}\\n\n--]\\n\n-- ```\n-- </command>\n-- <param name=\"grid\" optional=\"1\" type=\"[8, 16]\">Performs the swing offset either on 8th or 16th. (Default=8)</param>\n-- <param name=\"offset\" optional=\"1\" type=\"0..100\">The ammount of the swing offset</param>\n\nrequire \"lua/com/com\"\n\nparameters = {\n    -- can be 8, 16\n    { name=\"grid\",      default=\"8\" },\n    -- can be between 0 and 100\n    { name=\"offset\",    default=\"100\" }\n}\n\n\nfunction compareQuarters(a, b)\n    return math.abs(a-b) <= 0.1\nend\n\nfunction isLaidBack(timeinfo, grid)\n    local q = timeinfo.quarterPosition\n    q = q - math.floor(q)\n    if grid == 16 then\n        return compareQuarters(q, 0.25) or compareQuarters(q, 0.75)\n    end\n    return compareQuarters(q, 0.5)\nend\n\nfunction offset(grid, offset)\n    if offset == nil then\n        offset = 100\n    end\n    offset = offset / 100\n    local max = 0.25\n    if grid == 16 then\n        max = 0.09\n    end\n    return offset * max\nend\n\nfunction perform(events, params, timeinfo)\n    checkLegacyNamedParams(params, \"grid\", \"offset\")\n    local gridValue   = tonumber(params.grid)\n    local offsetValue = tonumber(params.offset)\n    for i, event in pairs(events) do\n        if isLaidBack(timeinfo, gridValue) then\n            event.offset = offset(gridValue, offsetValue)\n            event.velocity = event.velocity\n        end\n    end\n    return events\nend"}, {"path": "lua/voicings/config.lua", "data": "PitchRanges = {\n    contrabass   = { min=28, max=55 },\n    bass         = { min=40, max=60 },\n    baritone     = { min=45, max=69 },\n    tenor        = { min=48, max=72 },\n    alto         = { min=53, max=77 },\n    mezzosoprano = { min=57, max=81 },\n    soprano      = { min=60, max=84 }\n}"}, {"path": "lua/voicings/guitar.lua", "data": "-- <command name=\"guitar\" where=\"voicingStrategy\" using=\"lua/voicings/guitar.lua\">\n-- <![CDATA[\n-- Tries to simulate the chord voicing of an guitar.\n-- ```language=Werckmeister\\n\n--using \"lua/voicings/guitar.lua\";\\n\n--using \"chords/default.chords\";\n--tempo: 120;\\n\n--device: MyDevice  midi 0;\\n\n--instrumentDef:piano  MyDevice  _ch=0 _pc=0;\\n\n--[\\n\n--type: template;\\n\n--name: myTemplate;\\n\n--instrument: piano;\\n\n--{\\n\n--   /voicingStrategy: guitar/\\n\n--   <I II III IV V VI VII>1\\n\n--}\\n\n--]\\n\n--[\\n\n--type: accomp;\n--{\\n\n--  C | F | G | C |\\n\n--}\\n\n--]\\n\n-- ```\n-- ]]>\n-- </command>\n-- <param name=\"range\" optional=\"1\" type=\"[contrabass,bass,baritone,tenor,alto,mezzosoprano,soprano]\">If given the strategy tries to keeps the range by shifting the octave of the chord.</param>\n\nrequire \"lua/com/com\"\nrequire \"lua/com/globals\"\nrequire \"solvers/guitar\"\n\nparameters = {\n    table.unpack(ASolverDefaultParameter)\n}\n\nlocal solver = GuitarSolver:new()\n\nfunction solve(chord, degrees, params, timeinfo)\n    return solver:solve(chord, degrees, params)\nend"}, {"path": "lua/voicings/simple.lua", "data": "-- <command name=\"simple\" where=\"voicingStrategy\" using=\"lua/voicings/simple.lua\">\n-- <![CDATA[\n-- The simple approach with no strategy.\n-- ```language=Werckmeister\\n\n--using \"lua/voicings/simple.lua\";\\n\n--using \"chords/default.chords\";\n--tempo: 120;\\n\n--device: MyDevice  midi 0;\\n\n--instrumentDef:piano  MyDevice  _ch=0 _pc=0;\\n\n--[\\n\n--type: template;\\n\n--name: myTemplate;\\n\n--instrument: piano;\\n\n--{\\n\n--   /voicingStrategy: simple/\\n\n--   <I II III IV V VI VII>1\\n\n--}\\n\n--]\\n\n--[\\n\n--type: accomp;\n--{\\n\n--  C | F | G | C |\\n\n--}\\n\n--]\\n\n-- ```\n-- ]]>\n-- </command>\n-- <param name=\"range\" optional=\"1\" type=\"[contrabass,bass,baritone,tenor,alto,mezzosoprano,soprano]\">If given the strategy tries to keeps the range by shifting the octave of the chord.</param>\n\nrequire \"lua/com/com\"\nrequire \"solvers/simple\"\nrequire \"solvers/asolver\"\n\nparameters = {\n    table.unpack(ASolverDefaultParameter)\n}\n\nlocal solver = Simple:new()\n\nfunction solve(chord, degrees, parameters)\n    return solver:solve(chord, degrees, parameters)\nend"}, {"path": "lua/voicings/voicelead.lua", "data": "-- <command name=\"voicelead\" where=\"voicingStrategy\" using=\"lua/voicings/voicelead.lua\">\n-- <![CDATA[\n-- Tries to simulates a voice leading approach:\n-- the octaves of a chord are rearranged, so that the actual pitch distance between the previous chord is kept minimal.\n-- ```language=Werckmeister\\n\n--using \"lua/voicings/voicelead.lua\";\\n\n--using \"chords/default.chords\";\n--tempo: 120;\\n\n--device: MyDevice  midi 0;\\n\n--instrumentDef:piano  MyDevice  _ch=0 _pc=0;\\n\n--[\\n\n--type: template;\\n\n--name: myTemplate;\\n\n--instrument: piano;\\n\n--{\\n\n--   /voicingStrategy: voicelead/\\n\n--   <I II III IV V VI VII>1\\n\n--}\\n\n--]\\n\n--[\\n\n--type: accomp;\n--{\\n\n--  C | F | G | C |\\n\n--}\\n\n--]\\n\n-- ```\n-- ]]>\n-- </command>\n-- <param name=\"range\" optional=\"1\" type=\"[contrabass,bass,baritone,tenor,alto,mezzosoprano,soprano]\">If given the strategy tries to keeps the range by shifting the octave of the chord.</param>\n\nrequire \"lua/com/com\"\nrequire \"lua/com/globals\"\nrequire \"solvers/voicelead\"\n\nparameters = {\n    table.unpack(ASolverDefaultParameter)\n}\n\nlocal solver = VoiceLeadSolver:new()\n\nfunction solve(chord, degrees, params)\n    return solver:solve(chord, degrees, params)\nend"}, {"path": "lua/voicings/solvers/asolver.lua", "data": "require \"config\"\nrequire \"lua/com/com\"\n\nNoRangeSet = \"__noRangeSet\"\nNoImportantDegreesSet = \"_noImportantDegreesSet\"\n\nASolverDefaultParameter = {\n    -- can be contrabass, bass, baritone, tenor, alto, mezzosoprano, soprano\n    { name=\"range\",             default=NoRangeSet },\n    { name=\"importantDegrees\",  default=NoImportantDegreesSet },\n    { name=\"importantDegree\",   default=NoImportantDegreesSet },\n}\nASolver = {}\n\nfunction ASolver:new(o)\n    local o = o or {}\n    setmetatable(o, self)\n    self.__index = self\n    return o\nend\n\nfunction ASolver:checkForLegacyParameters(params)\n    checkLegacyNamedParams(params, \"range\", \"importantDegrees\", \"importantDegree\")\nend\n\n-- returns the a degree def from the given degree def collection\n-- if more than one degree def defined, it will return the first one\nfunction ASolver:getDefaultDegreeDef(degreeValue, degrees)\n    local default = degrees[degreeValue]\n    if default == nil \n    then\n        return nil\n    end\n    return default[1]\nend\n\n-- creates a absolute pitch using the given chord\nfunction ASolver:createPitch(chord, degreeDef, octave)\n    if degreeDef == nil or degreeDef.degreeValue == nil\n    then\n        return nil\n    end\n    return { [\"pitch\"]= self:degreeToPitch(degreeDef, chord), [\"octave\"]=octave }\nend\n\nfunction ASolver:degreeToPitch(degreeDef, chord)\n    return chord.rootPitch + degreeDef.degreeValue\nend\n\nfunction ASolver:getAbsolutePitch(pitch)\n    return pitch.pitch + (pitch.octave * 12)\nend\n\nfunction ASolver:_addImportantDegree(degrees, degreeVal, semitone)\n    local degreeInfo = self:getDefaultDegreeDef(degreeVal, degrees)\n    if degreeInfo==nil then\n        return\n    end\n    local degrObj = {\n        degreeValue= semitone,\n        octave= degreeInfo.octave\n    }\n    degrees[degreeVal] = {degrObj}\nend\n\n-- set important degrees if defined in params\n-- more informations about important degrees:\n-- https://github.com/werckme/werckmeister/issues/123\nfunction ASolver:_setImportantDegreesIfExists(params, degrees)\n    local strDegree = params.importantDegree\n    if (strDegree == nil or strDegree == NoImportantDegreesSet) then\n        strDegree = params.importantDegrees\n        if strDegree == nil or strDegree == NoImportantDegreesSet then\n            return\n        end\n    end\n    local strDegrees = split(strDegree, \" \")\n    for i, degree in pairs(strDegrees) do   \n        local degreeVal = DegreeStringValues[degree]\n        if degreeVal ~= nil then\n            local semitone = MajorScaleSemitones[degree]\n            self:_addImportantDegree(degrees, degreeVal, semitone)\n        end\n    end\nend\n\n-- solves degrees into absolute pitches\n-- @param chord: the current cord informations\n-- @param degrees: the current degree event including the semitone informations from \n--                 the chord definition eg.: { II= {degreeValue, octave} }\n--                 If the current chord has no information about a degree\n--                 the value is empty eg.: II= {} \nfunction ASolver:solve(chord, degrees, params)\n    self:checkForLegacyParameters(params)\n    self:_setImportantDegreesIfExists(params, degrees)\n    local result = self:_solveImpl(chord, degrees, params)\n    if params.range ~= nil and params.range ~=NoRangeSet then\n        self:_keepRange(result, params.range)\n    end\n    return result\nend\n\nfunction ASolver:_solveImpl(chord, degrees, args)\n    error(\"this is an abstract function\")\nend\n\nfunction ASolver:_transpose(pitches, numOctaves)\n    for i, pitch in pairs(pitches) do\n        pitch.octave = pitch.octave + numOctaves\n    end\nend\n\nfunction ASolver:_keepRange(pitches, strRange)\n    local destinationRange = PitchRanges[strRange]\n    if destinationRange == nil then\n        error(\"strRange \" .. strRange .. \" not defined\")\n    end\n    local nbUnder = 0\n    local nbOver = 0\n    local mindiff = math.maxinteger\n    local maxdiff = math.mininteger\n    for i, pitch in pairs(pitches) do\n        local midipitch = toMidiPitch(pitch)\n        if midipitch > destinationRange.max then\n            local diff = midipitch - destinationRange.max\n            if diff > maxdiff then\n                maxdiff = diff\n            end\n            nbOver = nbOver + 1\n        end\n        if midipitch < destinationRange.min then\n            local diff = destinationRange.min - midipitch\n            if diff < mindiff then\n                mindiff = diff\n            end\n            nbUnder = nbUnder + 1\n        end\n    end\n    if nbUnder > nbOver then\n        local octaves = math.ceil(mindiff/12)\n        self:_transpose(pitches, octaves)\n    end\n    if nbUnder < nbOver then\n        local octaves = -math.ceil(maxdiff/12)\n        self:_transpose(pitches, octaves)\n    end\nend"}, {"path": "lua/voicings/solvers/config.lua", "data": "PitchRanges = {\n    contrabass   = { min=28, max=55 },\n    bass         = { min=40, max=60 },\n    baritone     = { min=45, max=69 },\n    tenor        = { min=48, max=72 },\n    alto         = { min=53, max=77 },\n    mezzosoprano = { min=57, max=81 },\n    soprano      = { min=60, max=84 }\n}"}, {"path": "lua/voicings/solvers/guitar.lua", "data": "require \"lua/voicings/solvers/asolver\"\nrequire \"lua/com/globals\"\n\n-- https://www.8notes.com \n-- https://www.oolimo.de/gitarrenakkorde/find\n-- https://www.scales-chords.com/chord/piano/\nVoicingMatrix = {\n    [\"1234567/bass\"] = nil,\n    [\"1010100\"] = {I, V, I, III, I},            -- base\n    [\"1100100\"] = {I, V, I, II },               -- sus2\n    [\"1001100\"] = {I, V, I, IV, V },            -- sus4\n    [\"1001101\"] = {I, V, VII, IV, V},           -- 7sus4\n    [\"1101101\"] = {I, IV, VII, II, V},          -- 9sus4\n    [\"1010110\"] = {I, VI, III, V},              -- 6\n    [\"1110110\"] = {I, VI, III, V, II},          -- 6/9\n    [\"1010101\"] = {I, V, VII, III, I},          -- 7\n    [\"1110101\"] = {I, III, VII, II},            -- 9\n    [\"1110100\"] = {I, V, II, III},              -- add9\n    [\"1011101\"] = {I, IV, VII, III},            -- 11\n    [\"1011001\"] = {I, VII, III, IV},            -- 7#11\n    [\"1010111\"] = {I, V, VII, III, VI},         -- 13\n    [\"1010101/7\"] = {VII, V, I, III},           -- /7\n    [\"1010100/5\"] = {V, I, III, V},             -- /5\n    [\"1011100/4\"] = {IV, V, I, III},            -- /4\n    [\"1010100/3\"] = {III, V, I, III},           -- /3\n    [\"1110100/2\"] = {II, V, I, III},            -- /2\n}\n\n\n-- returns the degrees defined for a chord as a bit string.\n-- e.g.: Xmaj's degrees are defined as I III V\n--                1234567\n-- as bitstring = 1010100\n-- if chord is a slash chord, the degree value will be appended as number.\n-- e.g.: X/V = 1010100/5\nfunction chordToHashString(chord)\n    bits = {}\n    slashAppendings = {}\n    local degree = chord.degrees\n    for i=1, 7 do\n        if degree[i] == nil then\n            bits[i] = 0\n        else\n            bits[i] = 1\n            if chord.degrees[i] < 0 then\n                table.insert(slashAppendings, i)\n            end\n        end\n    end\n    if #slashAppendings == 0 then\n        return table.concat(bits)\n    end\n    return table.concat(bits) .. \"/\" .. table.concat(slashAppendings)\nend\n\nGuitarSolver = ASolver:new()\n\nfunction GuitarSolver:degreeToPitch(degreeDef, chord)\n    return chord.rootPitch + (degreeDef.degreeValue % 12)\nend\n\nfunction GuitarSolver:_solveImpl(chord, degrees, params)\n    local d = function(degreeValue) return self:getDefaultDegreeDef(degreeValue, degrees) end\n    local strDegrees = chordToHashString(chord)\n    local voicing = VoicingMatrix[strDegrees]\n    if voicing == nil then\n        error(\"no voicing found defined for \" .. chord.strBase .. chord.strOptions .. \" \" .. strDegrees)\n    end\n    local result = {}\n    local octave = -1\n    local lastDegree = -1\n    for idx, degree in pairs(voicing) do\n        if degree <= lastDegree then \n            octave = octave + 1\n        end\n        lastDegree = degree\n        result[idx] = self:createPitch(chord, d(degree  ), octave)\n    end\n    return result\nend"}, {"path": "lua/voicings/solvers/simple.lua", "data": "require \"lua/voicings/solvers/asolver\"\nrequire \"lua/com/globals\"\n\nSimple = ASolver:new()\n\nfunction Simple:degreeToPitch(degreeDef, chord)\n    return chord.rootPitch + degreeDef.degreeValue\nend\n\nfunction Simple:_solveImpl(chord, degrees, parameters)\n    local pitches = {}\n    for degree, degreeDefs in pairs(degrees)\n    do\n        if isnumber(degree)\n        then\n            for idx, degreeDef in pairs(degreeDefs)\n            do\n                table.insert(pitches, self:createPitch(chord, degreeDef, degreeDef.octave))\n            end\n        end\n    end\n    return pitches\nend"}, {"path": "lua/voicings/solvers/voicelead.lua", "data": "require \"simple\"\nrequire \"lua/com/globals\"\n\nVoiceLeadSolver = Simple:new()\n\nfunction VoiceLeadSolver:getPitchWithMinDistance(pitch, pitches)\n    local min = math.maxinteger\n    local minPitch = nil\n    local relPitch = pitch.pitch % 12\n    for i, refpitch in pairs(pitches) do\n        local diff = relpitchdiff(refpitch.pitch, relPitch)\n        diff = math.abs(diff)\n        if (diff < min) then\n            minPitch = refpitch\n            min = diff\n        end\n    end\n    return minPitch\nend\n\n-- changes the octave of pitch, so that the interval\n-- between pitch and targetPitch is minimal\nfunction VoiceLeadSolver:toPitchNextTo(pitch, targetPitch)\n    if targetPitch == nil then\n        return pitch\n    end\n    local diff = pitch.pitch - targetPitch.pitch\n    pitch.octave = targetPitch.octave\n    --print(pitch.pitch, targetPitch.pitch, diff)\n    if (diff > 6) then\n        pitch.octave = pitch.octave - 1\n    end\n    if (diff < -6) then\n        pitch.octave = pitch.octave + 1\n    end\n    return pitch\nend\n\n\n-- compare pitches with a reference and adjust octaves\nfunction VoiceLeadSolver:adjustOctaves(pitches, reference)\n    for i, pitch in pairs(pitches) do\n        local min = self:getPitchWithMinDistance(pitch, reference) \n        self:toPitchNextTo(pitch, min)\n    end\n    return pitches\nend\n\nfunction VoiceLeadSolver:_solveImpl(chord, degrees, params)\n    local pitches = Simple:_solveImpl(chord, degrees, params)\n    if #pitches < 2\n    then\n        return pitches\n    end\n    if self.previous ~= nil \n    then\n        pitches = self:adjustOctaves(pitches, self.previous)\n    end\n    return pitches\nend\n\nfunction VoiceLeadSolver:solve(chord, degrees, params)\n    self:checkForLegacyParameters(params)\n    local result = self:_solveImpl(chord, degrees, params)\n    if params.range ~=nil and params.range ~=NoRangeSet then\n        self:_keepRange(result, params.range)\n    end\n    self.previous = result\n    return result\nend"}, {"path": "pitchmaps/battery3.tight.pitchmap", "data": "\"bd\": c,,\n\"sn\": d,,\n\"sng\": g#       --snare ghost notes\n\"ss\": c#,,      -- sidestick\n\"hc\": d#,,      -- handclap\n\"ht\": f#,,      -- hihat closed\n\"hf\": g#,,      -- hihat foot\n\"ho\": bb,,      -- hihat open\n\"ho1\": g'       -- hihat half open1\n\"ho2\": g#'      -- hihat half open2\n\"ho3\": a'       -- hihat half open3\n\"cy\": c#,\n\"hto\": c,\n\"hto1\": c,\n\"hto2\": d,\n\"mto\": b,,\n\"mto1\": b,,\n\"mto2\": a,,\n\"lto\": g,,\n\"lto1\": g,,\n\"lto2\": f,,\n\"rdbell\": f#,\n\"mtr\": ab'\n\"otr\": a'\n-- r&l\n\"snl\": d,,\n\"snr\": e,,\n\"riml\": c#,,\n\"rimr\": d#,,\n\"htol\": e,\n\"htor\": f,\n\"mtol\": c,\n\"mtor\": d,\n\"ltol\": b,,\n\"ltor\": a,,\n\"ftol\": g,,\n\"ftor\": f,,\n"}, {"path": "pitchmaps/defaultMidiDrumMap.pitchmap", "data": "\"bd\": c,,,,\n\"sn\": d,,\n\"sng\": d,,      --snare ghost notes\n\"ss\": c#,,     -- sidestick\n\"hc\": d#,,     -- handclap\n\"ht\": f#,,     -- hihat closed\n\"hf\": g#,,     -- hihat foot\n\"ho\": bb,,     -- hihat open\n\"ho1\": bb,,    -- hihat half open1\n\"ho2\": bb,,    -- hihat half open2\n\"ho2\": bb,,    -- hihat half open3\n\"cy\": c#,      -- crash cymal\n\"spl\": g,       -- splash cymal\n\"hto\": c,       -- high tom \n\"hto1\": c,\n\"hto2\": d,\n\"mto\": b,,      -- middle tom\n\"mto1\": b,,\n\"mto2\": a,,\n\"lto\": g,,      -- low tom\n\"lto1\": g,,\n\"lto2\": f,,\n\"rdbell\": b,\n\"mtr\": ab'    -- muted triangle\n\"otr\": a'     -- open triangle\n\"bo1\": c      --bongo 1\n\"bo2\": c#    --bongo 2\n\"tim1\": f     --timbale 1\n\"tim2\": f#   --timbale 2\n\"ago1\": g     --agogo 1\n\"ago2\": g#   --agogo 2\n\"cui1\": f#'  -- cuica 1\n\"cui2\": g'    -- cuica 2\n\"cwb\": g#,   -- cowbell\n\"cla\": d#'   -- claves"}, {"path": "templates/bass.blues.template", "data": "[\ntype: template;\nname: bass.blues.normal;    \ninstrument: bass;\n{\n    /do: swing _grid=8 _offset =60/\n    I,,,8 &  I,,&  VII,,,&  V,,,&  |\n}\n]"}, {"path": "templates/bass.bossanova.template", "data": "[\ntype: template;\nname: bass.bossanova.normal;\ninstrument: bass; \n{\n    \\fff\n    I,,4. V,,8 V,,4. I,,8  |\n    I,,4. V,,8 V,,4 I,,4  |\n    I,,4. V,,8 V,,4. I,,8  |\n    I,,4. V,,8 V,,4 I,,8 V,,8  |\n}    \n] \n"}, {"path": "templates/bass.country.template", "data": "[\ntype: template;\nname: bass.country.normal;\ninstrument: bass; \n{\n    I,,4. I,,8 V,,,4. V,,,8 |\n}   \n] \n\n[\ntype: template;\nname: bass.country.ende;\ninstrument: bass; \n{\n    I,,1 |\n}   \n] "}, {"path": "templates/bass.disco.template", "data": "[\ntype: template;\nname: bass.disco.normal;\ninstrument: bass;\n{\n    \\ffff\n    I,,8 I,16 I,16  I,,8 I,16 I,16  I,,8 I,16 I,16  I,,8 I,16 I,16 |\n}   \n]\n"}, {"path": "templates/bass.reggae.template", "data": "using \"lua/mods/swing.lua\";\n\n[\ntype: template;\nname: bass.reggae.normal;\ninstrument: bass;\n{\n    /do: swing _grid=8 _offset =30/\n    I,,16 r16  I,,8   r2        V,,,4    |\n    I,,16 r16    r8   I,,8 r4.  V,,,4    |\n    I,,16 r16  I,,8   r2        V,,,4    |\n    I,,16 r16  I,,8   r2        V,,,4    |\n}\n]"}, {"path": "templates/bass.soca.template", "data": "[\ntype: template;\nname: bass.soca.normal;\ninstrument: bass;\n{\n    r8 r16 I,,32 r32 I,,8  I,,16 r \n    r8 r16 I,,32 r32  r16 I,,32 r  V,,, r I,, r  |\n}\n]"}, {"path": "templates/bossanova.template", "data": "using \"lua/voicings/voicelead.lua\";\nusing \"lua/voicings/simple.lua\";\nusing \"lua/voicings/guitar.lua\";\nusing \"lua/mods/guitarStroke.lua\";\n\n[\ntype: template;\nname: bossanova.normal;\ninstrument: drums;\n{\n    \"ht\"8 !f\"ht\" \"ht\" !f\"ht\"   \"ht\" \"ht\" \"ht\" !f\"ht\" |\n}    \n{\n    \\fff\n    r4 \"ss\"8 r4 \"ss\"8 r4 | \"ss\"4. \"ss\"8 r4 \"ss\" |\n}    \n{\n    \"bd\"4. \"bd\"8 \"bd\"4. \"bd\"8 |\n}      \n]\n\n[\ntype: template;\nname: bossanova.normal;\ninstrument: guitar; \n{\n    /do: guitarStroke _value=32/\n    /voicingStrategy: guitar/\n    \\f\n    <I II III IV V VI VII>4 <I II III IV V VI VII>4 r8 <I II III IV V VI VII>8 r8 <I II III IV V VI VII>8  |\n    r8 <I II III IV V VI VII>8 r8 <I II III IV V VI VII>8 r4 <I II III IV V VI VII>4 |\n    <I II III IV V VI VII>4 <I II III IV V VI VII>4 r8 <I II III IV V VI VII>8 r8 <I II III IV V VI VII>8  |\n    r4 r8 <I II III IV V VI VII>8 r8 <I II III IV V VI VII>4. |\n}    \n] \n\n[\ntype: template;\nname: bossanova.normal;\ninstrument: piano; \n{\n   -- /voicingStrategy: simple _range=tenor/\n    <VII, VII>4 <III, V,>8 <V, V>8 r8 <III, V,>8 r8 <V, V> | r8 <III, V,>8 r8 <V, V> r8 <III, V,> r8 <VII, VII> |\n}    \n] \n\n[\ntype: template;\nname: bossanova.normal;\ninstrument: bass; \n{\n    \\fff\n    I,,4. V,,8 V,,4. I,,8  |\n    I,,4. V,,8 V,,4 I,,4  |\n    I,,4. V,,8 V,,4. I,,8  |\n    I,,4. V,,8 V,,4 I,,8 V,,8  |\n}    \n] \n"}, {"path": "templates/countryschlager1.template", "data": "using \"lua/voicings/guitar.lua\";\nusing \"lua/voicings/voicelead.lua\";\nusing \"lua/mods/guitarStroke.lua\";\n\n[\ntype: template;\nname: countryschlager1.normal;\ninstrument: guitar; \n{\n    /do:  guitarStroke/\n    /voicingStrategy: guitar _range=tenor/\n    \\f\n    <I II III IV V VI VII>8 <I II III IV V VI VII>8 r8 \n    <I II III IV V VI VII>4  <I II III IV V VI VII>8 <I II III IV V VI VII>8 <I II III IV V VI VII>8 |\n}   \n]\n\n[\ntype: template;\nname: countryschlager1.normal;\ninstrument: slide; \n{\n    \\f\n    /modOnce: bend from 0/\n    r1 |\n    r1 |\n    r1 |\n    <I' II' III' IV' V' VI' VII'>1 |\n    r1 |\n    r1 |\n    r1 |\n    /modOnce: bend to 100/\n    <I' II' III' IV' V' VI' VII'>1 |\n}   \n]  \n\n[\ntype: template;\nname: countryschlager1.normal;\ninstrument: bass; \n{\n    I,,4. I,,8 V,,,4. V,,,8 |\n}   \n] \n\n[\ntype: template;\nname: countryschlager1.normal;\ninstrument: drums;\n{\n    \"ht\"8 !f\"ht\"8 \"ht\"8 !f\"ht\"8 \"ht\"8 !f\"ht\"8 \"ht\"8 !f\"ht\"8 |\n}    \n{\n    r4 \"sn\" r \"sn\" |\n}\n{\n    \"bd\"4. \"bd\"8 \"bd\"4. \"bd\"8 |\n    \"bd\"4. \"bd\"8 \"bd\"4. \"bd\"8 |\n    \"bd\"4. \"bd\"8 \"bd\"8 !f\"bd\"8 r8 \"bd\"8 |\n}      \n] \n\n[\ntype: template;\nname: countryschlager1.ende;\ninstrument: guitar; \n{\n    /do:  guitarStroke _value=8/\n    <I II III IV V VI VII>1  |\n}   \n] \n\n[\ntype: template;\nname: countryschlager1.ende;\ninstrument: bass; \n{\n    I,,1 |\n}   \n] \n\n[\ntype: template;\nname: countryschlager1.ende;\ninstrument: drums;\n{\n    \"cy\"1 |\n}    \n{\n    \"bd\"1|\n}      \n]\n\n[\ntype: template;\nname: countryschlager1.ende;\ninstrument: slide; \n{\n    \\f\n    /modOnce: bend from 1/\n    <I' II' III' IV' V' VI' VII'>1 |\n}   \n]   \n"}, {"path": "templates/drums.bossanova.template", "data": "[\ntype: template;\nname: drums.bossanova.normal;\ninstrument: drums;\n{\n    \"ht\"8 !f\"ht\" \"ht\" !f\"ht\"   \"ht\" \"ht\" \"ht\" !f\"ht\" |\n}    \n{\n    \\fff\n    r4 \"ss\"8 r4 \"ss\"8 r4 | \"ss\"4. \"ss\"8 r4 \"ss\" |\n}    \n{\n    \"bd\"4. \"bd\"8 \"bd\"4. \"bd\"8 |\n}      \n]"}, {"path": "templates/drums.country.template", "data": "[\ntype: template;\nname: drums.country.normal;\ninstrument: drums;\n{\n    \"ht\"8 !f\"ht\"8 \"ht\"8 !f\"ht\"8 \"ht\"8 !f\"ht\"8 \"ht\"8 !f\"ht\"8 |\n}    \n{\n    r4 \"sn\" r \"sn\" |\n}\n{\n    \"bd\"4. \"bd\"8 \"bd\"4. \"bd\"8 |\n    \"bd\"4. \"bd\"8 \"bd\"4. \"bd\"8 |\n    \"bd\"4. \"bd\"8 \"bd\"8 !f\"bd\"8 r8 \"bd\"8 |\n}      \n] \n\n[\ntype: template;\nname: drums.country.cymbal;\ninstrument: drums;\n{\n    \"cy\"4 \"ht\"8 !f\"ht\"8 \"ht\"8 !f\"ht\"8 \"ht\"8 !f\"ht\"8 |\n}    \n{\n    r4 \"sn\" r \"sn\" |\n}\n{\n    \"bd\"4. \"bd\"8 \"bd\"4. \"bd\"8 |\n}      \n] \n\n[\ntype: template;\nname: drums.country.ende;\ninstrument: drums;\n{\n    \"cy\"1 |\n}    \n{\n    \"bd\"1|\n}      \n]"}, {"path": "templates/drums.disco.template", "data": "[\ntype: template;\nname: drums.disco.normal;\ninstrument: drums;\n{\n    r8 \"ht\"16 \"ht\"16 !ffff\"sn\"8 \"ht\"16 \"ht\"16 r8 \"ht\"16 \"ht\"16 !ffff\"sn\"8 \"ht\"16 \"ht\"16 |\n    r8 \"ht\"16 \"ht\"16 !ffff\"sn\"8 \"ht\"16 \"ht\"16 r8 \"ht\"16 \"ht\"16 !ffff\"sn\"8 !ffff<\"sn\" \"ht\">16 !fffff\"sn\"16 |\n    \"cy\"8 \"ht\"16 \"ht\"16 !ffff\"sn\"8 \"ht\"16 \"ht\"16 r8 \"ht\"16 \"ht\"16 !ffff\"sn\"8 \"ht\"16 \"ht\"16 |\n    r8 \"ht\"16 \"ht\"16 !ffff\"sn\"8 \"ht\"16 \"ht\"16 r8 \"ht\"16 \"ht\"16 !ffff\"sn\"8 <\"sn\" \"ht\">16 !fffff\"sn\"16 |\n}   \n{\n    \"bd\"4 \"bd\" \"bd\" \"bd\" |\n}   \n] \n\n[\ntype: template;\nname: drums.disco.solo;\ninstrument: drums;\n{\n    \"bd\"4 \"bd\" \"bd\" \"bd\" |\n}   \n] \n\n[\ntype: template;\nname: drums.disco.solo2;\ninstrument: drums;\n{\n    \"cy\"8 \"ht\"16 \"ht\"16 !ffff\"sn\"8 \"ht\"16 \"ht\"16 r8 \"ht\"16 \"ht\"16 !ffff\"sn\"8 \"ht\"16 \"ht\"16 |\n    r8 \"ht\"16 \"ht\"16 !ffff\"sn\"8 \"ht\"16 \"ht\"16 r8 \"ht\"16 \"ht\"16 !ffff\"sn\"8 <\"sn\" \"ht\">16 !fffff\"sn\"16 |\n}   \n{\n    \"bd\"4 \"bd\" \"bd\" \"bd\" |\n}   \n] "}, {"path": "templates/drums.purdie.template", "data": "[\ntype: template;\nname: drums.purdie.normal;\ninstrument: drums;     \n{\n    \\p\"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t   \"ht\"8t r8t !pp\"ht\"8t |\n    \\p\"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t   \"ht\"8t r8t !pp\"ht\"8t |\n    \\p\"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t   \"ht\"8t r8t !pp\"ht\"8t |\n    \\p\"ho\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t   \"ht\"8t r8t !pp\"ht\"8t |\n\n    \\p\"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t   \"ht\"8t r8t !pp\"ht\"8t |\n    \\p\"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t   \"ht\"8t r8t !pp\"ht\"8t |\n    \\p\"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t   r8t !pp\"ho\"8t !pp\"ht\"8t |\n    \\p\"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t   \"ht\"8t r8t !pp\"ht\"8t |\n\n    \\p\"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t   \"ht\"8t r8t !pp\"ht\"8t |\n    \\p\"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t   \"ht\"8t r8t !pp\"ht\"8t |\n    \\p\"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t    \"ht\"8t r8t !pp\"ht\"8t   \"ht\"8t r8t !pp\"ht\"8t |\n    \\f\"ho\"8t \"ht\"8t \"bd\"8t    \\f\"ho\"8t \"ht\"8t r8t     \"ht\"8t r8t !pp\"ht\"8t   \"ht\"8t r8t !pp\"ht\"8t |\n}\n{\n    r8t !pppp\"sng\"8t r8t    r8t !pppp\"sng\"8t r8t    \\ff\"sn\"8t !pppp\"sng\"8t r8t   r8t !pppp\"sng\"8t r8t |\n    r8t !pppp\"sng\"8t r8t    r8t !pppp\"sng\"8t r8t    \\ff\"sn\"8t !pppp\"sng\"8t r8t   r8t !pppp\"sng\"8t r8t |    \n    r8t !pppp\"sng\"8t r8t    r8t !pppp\"sng\"8t r8t    \\ff\"sn\"8t !pppp\"sng\"8t r8t   r8t !ppp\"sn\"8t !pp\"sn\"8t |\n    r8t !pppp\"sng\"8t r8t    r8t !pppp\"sng\"8t r8t    \\ff\"sn\"8t !pppp\"sng\"8t r8t   r8t !pppp\"sng\"8t r8t |\n\n    r8t !pppp\"sng\"8t r8t    r8t !pppp\"sng\"8t r8t    \\ff\"sn\"8t !pppp\"sng\"8t r8t   r8t !pppp\"sng\"8t r8t |\n    r8t !pppp\"sng\"8t r8t    r8t !pppp\"sng\"8t r8t    \\ff\"sn\"8t !pppp\"sng\"8t r8t   r8t !pppp\"sng\"8t r8t |    \n    r8t !pppp\"sng\"8t r8t    r8t !pppp\"sng\"8t r8t    \\ff\"sn\"8t !pppp\"sng\"8t r8t   r4t r8t              |   \n    r8t !pppp\"sng\"8t r8t    r8t !pppp\"sng\"8t r8t    \\ff\"sn\"8t !pppp\"sng\"8t r8t   r8t !pppp\"sng\"8t r8t |\n\n    r8t !pppp\"sng\"8t r8t    r8t !pppp\"sng\"8t r8t    \\ff\"sn\"8t !pppp\"sng\"8t r8t   r8t !pppp\"sng\"8t r8t |\n    r8t !pppp\"sng\"8t r8t    r8t !pppp\"sng\"8t r8t    \\ff\"sn\"8t !pppp\"sng\"8t r8t   r8t !pppp\"sng\"8t r8t |    \n    r8t !pppp\"sng\"8t r8t    r8t !pppp\"sng\"8t r8t    \\ff\"sn\"8t !pppp\"sng\"8t r8t   r8t !ppp\"sn\"8t !pp\"sn\"8t |\n    r8t !pppp\"sng\"8t r8t    r8t !pppp\"sng\"8t r8t    \\ff\"sn\"8t !pppp\"sng\"8t r8t   r8t !pppp\"sng\"8t r8t |   \n}\n{\n    \"bd\"4t r8t r4t \"bd\"8t r4t r8t \"bd\"4t r8t |\n}\n]"}, {"path": "templates/drums.reggae.template", "data": "using \"lua/mods/swing.lua\";\n\n\n[\ntype: template;\nname: drums.reggae.normal;\ninstrument: drums; \n{\n\n}\n{\n    /do: swing _grid=8 _offset =50/\n    !f\"ht\"4     &8 !p&                \"ht\"4        &8 !p&|\n    !f\"ht\"4     \"ht\"8t & &          \"ht\"4        &8 !p&|\n    !f\"ht\"4     !pp\"ho1\"4           \"ht\"4        &8 !p&|\n}\n{\n    r           r         \"bd\"4           r |\n    r           r         \"sn\"4           r |\n}\n]\n\n--\n\n[\ntype: template;\nname: drums.reggae.fill1;\ninstrument: drums; \n{\n\n}\n{\n    /do: swing _grid=8 _offset =50/\n    !f\"ht\"4     !p\"ho2\"4             r2      |\n}\n{\n    /do: swing _grid=8 _offset =50/\n    r   \"hto1\"64->\"hto1\"4.       \"mto1\"8       \"mto1\"8t r \"mto1\"   |\n}\n]\n\n[\ntype: template;\nname: drums.reggae.fill2;\ninstrument: drums; \n{\n\n}\n{\n    /do: swing _grid=8 _offset =50/\n    !f\"ht\"4     \"ht\"4            r2      |\n}\n{\n    /do: swing _grid=16 _offset =50/\n   !f\"tim1\"32->!p\"tim2\"8t & &  \"hto1\"4  r2  |\n}\n]\n"}, {"path": "templates/drums.soca.template", "data": "[\ntype: template;\nname: drums.soca.normal;\ninstrument: drums;\n{\n    \"ago1\"16 &  \"ago2\" &   \"ago1\" &  \"ago2\" &    \"ago1\"16 &  \"ago2\" &   \"ago1\" &  \"ago2\" &  |\n}\n{\n    \"cwb\"8 & &16 & r \"cwb\"   r16 \"cwb\" r \"cwb\"  \"cwb\" r  &  r | \n}\n{\n    \\p\n    \"ht\"16 & \"ho\"8 \"ht\"16 & \"ho\"8    \"ht\"16 & \"ho\"8 \"ht\"16 & \"ho\"8    |\n}\n{\n    \\ffff\n    r8. \"sn\"16 r8 \"sn\"    r8. \"sn\"16 r8 \"sn\"    |\n}\n{\n    \"bd\"4 \"bd\"   \"bd\" \"bd\" |\n}\n]\n\n[\ntype: template;\nname: drums.soca.bridge;\ninstrument: drums;\n{\n    \"ago1\"16 &  \"ago2\" &   \"ago1\" &  \"ago2\" &    \"ago1\"16 &  \"ago2\" &   \"ago1\" &  \"ago2\" &  |\n}\n{\n    \"cwb\"8 & &16 & r \"cwb\"   r16 \"cwb\" r \"cwb\"  \"cwb\" r  &  r | \n}\n{\n    \\fff\n    \"mtr\"16 & \"otr\"8 \"mtr\"16 & \"otr\"8 \"mtr\"16 & \"otr\"8 \"mtr\"16 & \"otr\"8 |\n}\n{\n    \\p\n    !ff\"spl\"16 \"ht\" \"ho\"8 \"ht\"16 & \"ho\"8    \"ht\"16 & \"ho\"8 \"ht\"16 & \"ho\"8    |\n    \"ht\"16 & \"ho\"8 \"ht\"16 & \"ho\"8    \"ht\"16 & \"ho\"8 \"ht\"16 & \"ho\"8    |\n}\n{\n    \\f\n    r4 r16 \"bo1\" \"bo2\" &    r4 r16 \"bo1\" \"bo2\" &  |\n}\n{\n    \\pp\n    r4 r16 \"cla\" r8  \"cla\" r16 \"cla\"16 r4  |\n}\n{\n    \\fffff\n    r8. \"sn\"16 r8 \"sn\"    r8. \"sn\"16 r8 \"sn\"    |\n    r8. \"sn\"16 r8 \"sn\"    r4 r16 !fff\"sn\" !ffff& !fffff&   |\n}\n{\n    \"bd\"4 \"bd\"   \"bd\" \"bd\" |\n}\n]"}, {"path": "templates/ennio.template", "data": "[\ntype: template;\nname: ennio.normal;\ninstrument: piano; \n{\n    !ffffI,,4 <II, III, IV, V, VI, VII,> <II, III, IV, V, VI, VII,> !fffV,,, |\n}\n] \n\n"}, {"path": "templates/guitar.bossanova.template", "data": "[\ntype: template;\nname: guitar.bossanova.normal;\ninstrument: guitar; \n{\n    /voicingStrategy: simpleGuitar/\n    \\f\n    <I II III IV V VI VII>4 <I II III IV V VI VII>4 r8 <I II III IV V VI VII>8 r8 <I II III IV V VI VII>8  |\n    r8 <I II III IV V VI VII>8 r8 <I II III IV V VI VII>8 r4 <I II III IV V VI VII>4 |\n    <I II III IV V VI VII>4 <I II III IV V VI VII>4 r8 <I II III IV V VI VII>8 r8 <I II III IV V VI VII>8  |\n    r4 r8 <I II III IV V VI VII>8 r8 <I II III IV V VI VII>4. |\n}    \n] "}, {"path": "templates/guitar.country.template", "data": "using \"lua/voicings/guitar.lua\";\n\n[\ntype: template;\nname: guitar.country.normal;\ninstrument: guitar; \n{\n    /voicingStrategy: guitar _range=mezzosoprano/\n    \\f\n    <I II III IV V VI VII>8 <I II III IV V VI VII>8 r8 \n    <I II III IV V VI VII>4  <I II III IV V VI VII>8 <I II III IV V VI VII>8 <I II III IV V VI VII>8 |\n}   \n]\n\n[\ntype: template;\nname: guitar.country.ende;\ninstrument: guitar; \n{\n    <I II III IV V VI VII>1  |\n}   \n] \n"}, {"path": "templates/rhythm.bossanova.template", "data": "[\ntype: template;\nname: rhythm.bossanova.normal;\ninstrument: rhythm; \n{\n    \\f\n    <I II III IV V VI VII>4 <I II III IV V VI VII>4 r8 <I II III IV V VI VII>8 r8 <I II III IV V VI VII>8  |\n    r8 <I II III IV V VI VII>8 r8 <I II III IV V VI VII>8 r4 <I II III IV V VI VII>4 |\n    <I II III IV V VI VII>4 <I II III IV V VI VII>4 r8 <I II III IV V VI VII>8 r8 <I II III IV V VI VII>8  |\n    r4 r8 <I II III IV V VI VII>8 r8 <I II III IV V VI VII>4. |\n}    \n] "}, {"path": "templates/rhythm.country.template", "data": "using \"lua/voicings/guitar.lua\";\n\n[\ntype: template;\nname: rhythm.country.normal;\ninstrument: rhythm; \n{\n    \\f\n    <I II III IV V VI VII>8 <I II III IV V VI VII>8 r8 \n    <I II III IV V VI VII>4  <I II III IV V VI VII>8 <I II III IV V VI VII>8 <I II III IV V VI VII>8 |\n}   \n]\n\n[\ntype: template;\nname: rhythm.country.ende;\ninstrument: rhythm; \n{\n    /doOnce: arpeggio/\n    <I II III IV V VI VII>4~ <I II III IV V VI VII>2.  |\n}   \n] \n"}, {"path": "templates/rhythm.reggae.template", "data": "using \"lua/mods/swing.lua\";\nusing \"lua/mods/staccato.lua\";\n\n[\ntype: template;\nname: rhythm.reggae.normal;\ninstrument: rhythm;\n{\n    \\f\n    /do: swing _grid=8 _offset =40/\n    r4   /modOnce: staccato _amount=100/ <I II III IV V VI VII>8  /modOnce: staccato _amount=40/ <I II III IV V VI VII>8 \n    r4   /modOnce: staccato _amount=100/ <I II III IV V VI VII>8  /modOnce: staccato _amount=40/ <I II III IV V VI VII>8  \n    |\n\n}\n]"}]